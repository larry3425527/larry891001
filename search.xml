<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Swagger介紹-Django API文件生成</title>
      <link href="/larry891001/2022/08/03/%E9%9B%9C7%E9%9B%9C8/SwaggerUI/"/>
      <url>/larry891001/2022/08/03/%E9%9B%9C7%E9%9B%9C8/SwaggerUI/</url>
      
        <content type="html"><![CDATA[<h2 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h2><ul><li>由於目前在正在做一個專案，寫了一個<code>Web API</code>，需要提供一份使用文件讓使用者查看，API文件的呈現方式有很多種<code>Markdown</code>、<code>Apiary</code>，還有等等要介紹的<code>Swagger</code>…等</li><li>撰寫這種文件需要花非常多時間，也必須制定出文件規範才能讓對接的使用者容易明瞭，這時候可以透過<code>Swagger / OpenAPI</code>來為我們產出文件</li><li>使用者可以依照<code>OpenAPI</code>規範，將自己的 API 撰寫成<code>YAML</code>或者<code>JSON</code>檔案，再藉由<code>swagger-ui</code>轉換成一個 API 文件網頁。這個網頁可以部署在主機，或者放在專案中，需要的時候在 local 架起來檢視</li></ul><h2 id="Online-Demo"><a href="#Online-Demo" class="headerlink" title="Online Demo"></a>Online Demo</h2><ul><li>一開始在看的時候，完全看不懂，幸好他們有提供線上的<a href="https://editor.swagger.io/">editor demo</a>，可以先從這個網站對照。<br><img src="https://i.imgur.com/cD341t6.png" alt="Swagger-io"></li><li>畫面左方就是<code>YAML</code>檔案，而右方則是依照左方所渲染出來的 ui 頁面。頁面很清楚地列出 API 的<code>description(描述)</code>以及<code>path(路徑)</code>，點開之後可以看到更多API的資訊，像是接受什麼<code>parameter(參數)</code>，以及會有什麼<code>response(回應)</code>。而且使用者點擊<code>try it out</code>可以直接使用 API ，達到同時查看以及測試 API的效果</li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><ul><li>假定已經有基本的<code>Django REST Framework</code>專案，額外增加 Swagger</li></ul><ol><li>用 Django REST framework swagger 套件 drf_yasg 生成 Swagger UI</li></ol><ul><li>drf-yasg 是一個可以在 Django REST framework 自動生成 Swagger 的套件。我們先用 pip 安裝：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install drf-yasg</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>再將 drf_yasg 加到的 settings.py：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&#x27;drf_yasg&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>修改 Django REST framework project 的 urls.py 新增 drf_yasg 的 URL（建議修改 openapi.Info 的 title、contact 等資訊）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"><span class="keyword">from</span> drf_yasg.views <span class="keyword">import</span> get_schema_view</span><br><span class="line"><span class="keyword">from</span> drf_yasg <span class="keyword">import</span> openapi</span><br><span class="line">...</span><br><span class="line">schema_view = get_schema_view(</span><br><span class="line">   openapi.Info(</span><br><span class="line">      title=<span class="string">&quot;Snippets API&quot;</span>,</span><br><span class="line">      default_version=<span class="string">&#x27;v1&#x27;</span>,</span><br><span class="line">      description=<span class="string">&quot;Test description&quot;</span>,</span><br><span class="line">      terms_of_service=<span class="string">&quot;https://www.google.com/policies/terms/&quot;</span>,</span><br><span class="line">      contact=openapi.Contact(email=<span class="string">&quot;contact@snippets.local&quot;</span>),</span><br><span class="line">      license=openapi.License(name=<span class="string">&quot;BSD License&quot;</span>),</span><br><span class="line">   ),</span><br><span class="line">   public=<span class="literal">True</span>,</span><br><span class="line">   permission_classes=(permissions.AllowAny,),</span><br><span class="line">)</span><br><span class="line">urlpatterns += [</span><br><span class="line">   url(<span class="string">r&#x27;^swagger(?P&lt;format&gt;\.json|\.yaml)$&#x27;</span>, schema_view.without_ui(cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-json&#x27;</span>),</span><br><span class="line">   url(<span class="string">r&#x27;^swagger/$&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;swagger&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-swagger-ui&#x27;</span>),</span><br><span class="line">   url(<span class="string">r&#x27;^redoc/$&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;redoc&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-redoc&#x27;</span>),</span><br><span class="line">   ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>完成後透過指令啟動 server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>訪問 <a href="http://127.0.0.1:8000/swagger/">http://127.0.0.1:8000/swagger/</a> 就可以看到swagger UI<br><img src="https://i.imgur.com/3QE3BM8.png" alt="Swagger-ui"></p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.errorbaker.tw/posts/cwc329/swagger-ui/">初探 swagger-ui</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10242295">[Day09]使用Swagger自動建立清晰明瞭的REST API文件 - 我與 ASP.NET Core 的 30天</a></li><li><a href="https://zoejoyuliao.medium.com/%E7%94%A8-django-rest-framework-%E6%92%B0%E5%AF%AB-restful-api-%E4%B8%A6%E7%94%9F%E6%88%90-swagger-%E6%96%87%E6%AA%94-%E4%B8%8B-%E7%94%9F%E6%88%90-swagger-%E6%96%87%E6%AA%94-60c45e04afa8">用 Django REST Framework 撰寫 RESTful API 並生成 Swagger 文檔（下） — 生成 Swagger 文檔</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 雜7雜8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker學習紀錄-在Docker中使用darknet並與python串接</title>
      <link href="/larry891001/2022/07/29/docker/docker_yolo/"/>
      <url>/larry891001/2022/07/29/docker/docker_yolo/</url>
      
        <content type="html"><![CDATA[<h2 id="實作流程"><a href="#實作流程" class="headerlink" title="實作流程"></a>實作流程</h2><ol><li><p>git clone Darknet github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/AlexeyAB/darknet.git   </span><br></pre></td></tr></table></figure></li><li><p>進入 darknet 修改 Makefile </p><ul><li>將<code>GPU, CUDNN, CUDNN_HALF, OPENCV</code>依照自己的需求做修改，由於要與python串接必須要將<code>LIBSO</code>設為1，產生<code>libdarknet.so</code><br><img src="https://i.imgur.com/F9TBSTb.png" alt="darknet_Makefile_settings"></li><li>由於dakrnet的Makefile中，在編譯時會使用到CUDA code， 所以要將<code>ARCH</code>這個flag與你最常使用的GPU做匹配，這樣會加快runtime，詳細說明可參考<a href="https://blog.csdn.net/shaojie_wang/article/details/121117277?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-121117277-blog-110091930.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-121117277-blog-110091930.pc_relevant_multi_platform_featuressortv2removedup&utm_relevant_index=1">NVIDIA GPU的架构代号</a>，在<a href="https://arnon.dk/matching-sm-architectures-arch-and-gencode-for-various-nvidia-cards/">Matching CUDA arch and CUDA gencode for various NVIDIA architectures</a>中可以找到自己的GPU所使用的架構，Makefile裡都有附只需要將自己的GPU架構反註解就行了<br><img src="https://i.imgur.com/FUkFxhU.png" alt="darknet_Makefile_GPUsetting"></li></ul></li><li><p>取得yolov4的weights檔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/AlexeyAB/darknet/releases/download/darknet_yolo_v3_optimal/yolov4.weights</span><br></pre></td></tr></table></figure></li><li><p>編寫Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#這次環境以ubuntu20.04、cuda11.2.0、cudnn8的image為例</span></span><br><span class="line"><span class="keyword">FROM</span> nvidia/cuda:<span class="number">11.2</span>.<span class="number">0</span>-cudnn8-devel-ubuntu20.<span class="number">04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;debconf debconf/frontend select Noninteractive&#x27;</span> | debconf-set-selections</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安裝darknet的必要依賴</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;45.43.38.82 developer.download.nvidia.cn&quot;</span> &gt;&gt; /etc/hosts &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get upgrade -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y  build-essential libopencv-dev\</span></span><br><span class="line"><span class="bash">    cmake python3-opencv python3-dev nano</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#這邊安裝vim，只是為了後續方便直接在container內做修改</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安裝python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt install -y --no-install-recommends python3 python3-pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -sf python3 /usr/bin/python \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -sf pip3 /usr/bin/pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install --upgrade pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install wheel setuptools  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在container中建立資料夾，並將本地端的darknet複製到container，並且編譯</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /workfolder/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /workfolder/darknet</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./darknet /workfolder/darknet</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /workfolder/darknet</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /workfolder/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>建立image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image build -t yolo:v01 .</span><br></pre></td></tr></table></figure></li><li><p>設定xhost +local:docker</p><ul><li>設定x視窗的權限，允許docker使用linux GUI介面，以用來顯示圖片</li><li>在 local:docker 前加一個加號(+)，代表允許接受由 local:docker 所傳來的 X 繪圖指令。</li></ul></li><li><p>運行image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --gpus all -it --network=host -e DISPLAY=<span class="variable">$DISPLAY</span> yolo:v01</span><br></pre></td></tr></table></figure><ul><li><code>--network</code>:可以設定在執行 Docker Container 要使用哪一種的網路模式，網路模式有 none、container、host、bridge、overlay… 等等的模式，它們是透過使用 Linux 的 libnetwork 所建立出來的網路模式</li><li><code>-e DISPLAY=$DISPLAY</code>，設定要將畫面呈現到何處，允許docker使用GUI，以用來顯示圖片</li></ul></li><li><p>先測試darknet的主要執行檔</p><ul><li>由於image在build時，已經編譯過了，運行image後，可以在darknet的資料夾裡ls，確認裡面是否有<code>libdarknet.so</code>以及<code>darknet</code>的主程式</li><li>補充:<ul><li>darknet： AlexeyAB/darknet 的主要執行檔。</li><li>darknet_image.py, darknet.py, darknet_video.py：透過呼叫 libdarknet.so ，可以在 Python 中直接調用 AlexeyAB/darknet 的一些主要功能，如訓練、測試、載入網路結構等。</li><li>libdarknet.so： AlexeyAB/darknet 使用 c 語言所撰寫的共享函式庫，可供其他程式語言呼叫。</li></ul></li><li>測試指令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./darknet detector <span class="built_in">test</span> cfg/coco.data cfg/yolov4.cfg yolov4.weights -ext_output data/dog.jpg</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/74H0Iwz.png" alt="prediction"></li></ul></li><li><p>python串接</p><ul><li>由於有了 <code>libdarknet.so</code> 檔案，我們可以直接引用darknet.py裡面所提供的函式直接做使用，如此一來就可以自己實作了</li><li>以下為參考程式: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> darknet</span><br><span class="line">cfg_path = <span class="string">&#x27;./cfg/yolov4.cfg&#x27;</span></span><br><span class="line">data_path = <span class="string">&#x27;./cfg/coco.data&#x27;</span></span><br><span class="line">weight_path = <span class="string">&#x27;yolov4.weights&#x27;</span></span><br><span class="line">network, class_names, class_colors = darknet.load_network(cfg_path,</span><br><span class="line">                                                            data_path,</span><br><span class="line">                                                            weight_path)</span><br><span class="line"></span><br><span class="line">width = darknet.network_width(network)</span><br><span class="line">height = darknet.network_height(network)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">darknet_helper</span>(<span class="params">img, width, height</span>):</span></span><br><span class="line">    darknet_image = darknet.make_image(width, height, <span class="number">3</span>)</span><br><span class="line">    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    img_resized = cv2.resize(img_rgb, (width, height),</span><br><span class="line">                            interpolation=cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get image ratios to convert bounding boxes to proper size</span></span><br><span class="line">    img_height, img_width, _ = img.shape</span><br><span class="line">    width_ratio = img_width / width</span><br><span class="line">    height_ratio = img_height / height</span><br><span class="line"></span><br><span class="line">    <span class="comment">#    run model on darknet style image to get detections</span></span><br><span class="line">    darknet.copy_image_from_bytes(darknet_image, img_resized.tobytes())</span><br><span class="line">    detections = darknet.detect_image(network, class_names, darknet_image)</span><br><span class="line">    darknet.free_image(darknet_image)</span><br><span class="line">    <span class="keyword">return</span> detections, width_ratio, height_ratio</span><br><span class="line"></span><br><span class="line"><span class="comment"># run test on person.jpg image that comes with repository</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;./data/dog.jpg&quot;</span>)</span><br><span class="line">detections, width_ratio, height_ratio = darknet_helper(image, width, height)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> label, confidence, bbox <span class="keyword">in</span> detections:</span><br><span class="line">left, top, right, bottom = darknet.bbox2points(bbox)</span><br><span class="line">left, top, right, bottom = <span class="built_in">int</span>(left * width_ratio), <span class="built_in">int</span>(top * height_ratio), <span class="built_in">int</span>(right * width_ratio), <span class="built_in">int</span>(bottom * height_ratio)</span><br><span class="line">cv2.rectangle(image, (left, top), (right, bottom), class_colors[label], <span class="number">2</span>)</span><br><span class="line">cv2.putText(image, <span class="string">&quot;&#123;&#125; [&#123;:.2f&#125;]&quot;</span>.<span class="built_in">format</span>(label, <span class="built_in">float</span>(confidence)),</span><br><span class="line">                    (left, top - <span class="number">5</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>,</span><br><span class="line">                    class_colors[label], <span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;predictions&#x27;</span>,image)</span><br><span class="line">    key = cv2.waitKey(<span class="number">90</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>): <span class="comment"># Esc</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;break&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/R2ZuehO.png" alt="python-prediction"></li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/AlexeyAB">AlexeyAB/darknet</a></li><li><a href="https://arnon.dk/matching-sm-architectures-arch-and-gencode-for-various-nvidia-cards/">Matching CUDA arch and CUDA gencode for various NVIDIA architectures</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10193457">Day 21：介紹 Docker 的 Network (二)</a></li><li><a href="https://notebooks.githubusercontent.com/view/ipynb?browser=chrome&color_mode=auto&commit=abd611e5e142802b8928fa97092e27c086c6a6f6&device=unknown&enc_url=68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f69736e616d646e617a696d2f594f4c4f2d56342d4f626a6563742d446574656374696f6e2f616264363131653565313432383032623839323866613937303932653237633038366336613666362f5265616c5f74696d655f594f4c4f76345f4f626a6563745f446574656374696f6e5f6f6e5f57656263616d5f696e5f476f6f676c655f436f6c61625f2537435f496d616765735f616e645f566964656f2e6970796e62&logged_in=false&nwo=isnamdnazim/YOLO-V4-Object-Detection&path=Real_time_YOLOv4_Object_Detection_on_Webcam_in_Google_Colab_%7C_Images_and_Video.ipynb&platform=android&repository_id=356862848&repository_type=Repository&version=98">YOLOv4 Object Detection on Webcam In Google Colab</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10269138?sc=hot">Day 21 - 嵌入 AlexeyAB/darknet 的 Python</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> cuda </tag>
            
            <tag> yolov4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker學習紀錄-在Docker中建立 nvidia/cuda image</title>
      <link href="/larry891001/2022/07/27/docker/docker_cuda/"/>
      <url>/larry891001/2022/07/27/docker/docker_cuda/</url>
      
        <content type="html"><![CDATA[<h2 id="安裝nvidia驅動"><a href="#安裝nvidia驅動" class="headerlink" title="安裝nvidia驅動"></a>安裝nvidia驅動</h2><ol><li>查看可安裝的驅動<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ubuntu-drivers list     </span><br></pre></td></tr></table></figure></li><li>安裝驅動(前者會自動安裝適合的驅動，後者可以指定驅動版本號)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ubuntu-drivers autoinstall</span><br><span class="line">$ sudo apt install nvidia-driver-版本號</span><br></pre></td></tr></table></figure></li><li>安裝完後重啟<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo reboot </span><br></pre></td></tr></table></figure></li><li>確認是否安裝成功<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nvidia-smi </span><br></pre></td></tr></table></figure></li></ol><p><img src="https://img.onl/GokCaX" alt="nvidia-smi"></p><h2 id="安裝NVIDIA-Container-Toolkit"><a href="#安裝NVIDIA-Container-Toolkit" class="headerlink" title="安裝NVIDIA Container Toolkit"></a>安裝NVIDIA Container Toolkit</h2><ul><li>在docker container中使用gpu加速運算必須安裝container toolkit</li><li>Docker內都已經包含了CUDA和大量nvidia的配件，所以我們並不需要在主機上安裝CUDA、CuDNN，省去了安裝的麻煩及繁雜版本的適配問題。</li></ul><ol><li>設定repo以及GPG key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ distribution=$(. /etc/os-release;<span class="built_in">echo</span> $ID<span class="variable">$VERSION_ID</span>) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br></pre></td></tr></table></figure></li><li>安裝nvidia-docker2<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install -y nvidia-docker2</span><br></pre></td></tr></table></figure></li><li>重啟docker<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li>測試是否安裝成功<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure><img src="https://img.onl/D2Qjf" alt="nvidia-smi"></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://ithelp.ithome.com.tw/articles/10252098">Day27：Docker in VM on PVE</a></li><li><a href="https://linnote.com/tensorflow-gpu-in-docker/">如何在Docker環境內使用GPU跑Tensorflow</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -746. Min Cost Climbing Stairs解題紀錄</title>
      <link href="/larry891001/2022/07/10/LeetCode/easy/746/"/>
      <url>/larry891001/2022/07/10/LeetCode/easy/746/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">LeetCode - 746. Min Cost Climbing Stairs</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>此題要求從<code>stair[0]</code>或<code>stair[1]</code>開始爬到<code>top</code>所需的最小<code>cost</code>，這題可以利用dp來解<code>dp[i] = 爬到第i階所需的最小cost</code></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(cost)</span><br><span class="line">        cost.append(<span class="number">0</span>)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,m+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>])+cost[i]</span><br><span class="line">        <span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -712. Minimum ASCII Delete Sum for Two Strings解題紀錄</title>
      <link href="/larry891001/2022/07/08/LeetCode/Mid/712/"/>
      <url>/larry891001/2022/07/08/LeetCode/Mid/712/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">LeetCode - 712. Minimum ASCII Delete Sum for Two Strings</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>給出两個字符串，可以在每個字符串中删除一些字符，得到相等的字符串。求删除的字符的ASCII最小和。這題使用<code>dp[i][j] =  lowest ASCII sum of deleted characters to make s1[0:i]==s2[0:j]</code>的想法去做就可以了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># dp[i][j] =  lowest ASCII sum of deleted characters to make s1[0:i]==s2[0:j] </span></span><br><span class="line">        <span class="comment"># ord(str) 將數字轉為ASCii</span></span><br><span class="line">        m = <span class="built_in">len</span>(s1)</span><br><span class="line">        n = <span class="built_in">len</span>(s2)</span><br><span class="line">        s1 = <span class="string">&#x27;#&#x27;</span>+s1</span><br><span class="line">        s2 = <span class="string">&#x27;#&#x27;</span>+s2</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _  <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#dp[0][0] = 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">             dp[i][<span class="number">0</span>] = <span class="built_in">ord</span>(s1[i]) + dp[i-<span class="number">1</span>][<span class="number">0</span>] </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">             dp[<span class="number">0</span>][j] = <span class="built_in">ord</span>(s2[j]) + dp[<span class="number">0</span>][j-<span class="number">1</span>] </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j]+<span class="built_in">ord</span>(s1[i]) , dp[i][j-<span class="number">1</span>]+<span class="built_in">ord</span>(s2[j]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -97. Interleaving String解題紀錄</title>
      <link href="/larry891001/2022/07/07/LeetCode/Mid/97/"/>
      <url>/larry891001/2022/07/07/LeetCode/Mid/97/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/interleaving-string/">LeetCode - 97. Interleaving String</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要求判斷s3這個字串是否由s1及s2交錯組成，這題使用dp就可以解決了定義<code>dp[i][j]: s3[0:i+j] 是不是由 s1[0:i] and s2[0:j]所組成</code></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        m ,n ,l = <span class="built_in">len</span>(s1),<span class="built_in">len</span>(s2),<span class="built_in">len</span>(s3)</span><br><span class="line">        <span class="keyword">if</span> m+n != l:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">## dp[i][j]: s3[0:i+j] 是不是由 s1[0:i] and s2[0:j]所組成</span></span><br><span class="line">        s1 = <span class="string">&#x27;#&#x27;</span>+s1</span><br><span class="line">        s2 = <span class="string">&#x27;#&#x27;</span>+s2</span><br><span class="line">        s3 = <span class="string">&#x27;#&#x27;</span>+s3</span><br><span class="line">        dp = [[ <span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = (dp[i-<span class="number">1</span>][<span class="number">0</span>]==<span class="literal">True</span> <span class="keyword">and</span> s1[i] == s3[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = (dp[<span class="number">0</span>][j-<span class="number">1</span>]==<span class="literal">True</span> <span class="keyword">and</span> s2[j] == s3[j])   </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i-<span class="number">1</span>][j] == <span class="literal">True</span> <span class="keyword">and</span> s1[i] == s3[i+j]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> dp[i][j-<span class="number">1</span>] == <span class="literal">True</span> <span class="keyword">and</span> s2[j] == s3[i+j]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -11. Container With Most Water解題紀錄</title>
      <link href="/larry891001/2022/07/05/LeetCode/Mid/11/"/>
      <url>/larry891001/2022/07/05/LeetCode/Mid/11/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/container-with-most-water/">LeetCode - 11. Container With Most Water</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要找出一個最大的<code>container</code>可以裝最多的水，也就是求最大的面積，可參考<a href="https://leetcode.com/problems/container-with-most-water/discuss/1069746/JS-Python-Java-C%2B%2B-or-2-Pointer-Solution-w-Visual-Explanation-or-beats-100">解法</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, H: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, i, j = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(H)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j):</span><br><span class="line">            <span class="keyword">if</span> H[i] &lt;= H[j]:</span><br><span class="line">                res = H[i] * (j - i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                res = H[j] * (j - i)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; ans: ans = res</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -128. Longest Consecutive Sequence解題紀錄</title>
      <link href="/larry891001/2022/07/04/LeetCode/Mid/128/"/>
      <url>/larry891001/2022/07/04/LeetCode/Mid/128/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">LeetCode - 128. Longest Consecutive Sequence</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要找出最長的連續數列，並回傳長度，我先將數列做<code>sort()</code>，然後再將重複的數刪掉。以<code>start</code>為起點，若下個數字為此數+1<br>就取它的長度，否則就將起點設為此數</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        nums.sort()</span><br><span class="line">        maxleng = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        nums = <span class="built_in">set</span>(nums)</span><br><span class="line">        nums = <span class="built_in">list</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i-<span class="number">1</span>] + <span class="number">1</span> != nums[i]:</span><br><span class="line">                start = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxleng = <span class="built_in">max</span>(maxleng,i-start+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxleng</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker學習紀錄-建立python image</title>
      <link href="/larry891001/2022/07/04/docker/docker_python/"/>
      <url>/larry891001/2022/07/04/docker/docker_python/</url>
      
        <content type="html"><![CDATA[<h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><ol><li><p>Pull所需Python image</p><ul><li>到<code>Docker Hub</code>找到所需要的Python image，並下載到本地(這裡以3.9.7為例)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull python:3.9.7-alpine3.13</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/pA3nsmq.png" alt="DockerHub"></li></ul></li><li><p>啟用測試</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run --rm -it python:3.9.7-alpine3.13</span><br></pre></td></tr></table></figure><ul><li><code>--rm</code>表示運行完容器之後，就將它刪除</li><li><code>-it</code>交互式的命令行方式</li></ul></li><li><p>確認Python、Pip、Linux的版本號</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run --rm -it python:3.9.7-alpine3.13 python -V</span><br><span class="line">$ sudo docker container run --rm -it python:3.9.7-alpine3.13 pip -V</span><br><span class="line">$ sudo docker container run --rm -it python:3.9.7-alpine3.13 cat /etc/os-release</span><br></pre></td></tr></table></figure></li><li><p>main.py</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">myarray = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(myarray)</span><br></pre></td></tr></table></figure></li><li><p>執行本地的Python應用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run --rm -it  -v &#123;所在資料夾&#125;:/workfolder:ro python:3.9.7-alpine3.13  python /workfolder/main.py</span><br></pre></td></tr></table></figure><ul><li>(運行容器)<br>(將本地的資料夾映射到<code>container</code>裡面的<code>workfolder</code>資料夾並且設成<code>ro</code>唯讀屬性)<br>(指定要運行的<code>image</code>)<br>(運行<code>image</code>裡面的<code>python</code>程序)</li><li>但由於上面的環境並沒有<code>numpy</code>，所以會報錯</li></ul></li><li><p>建立Dockerfile</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>.<span class="number">7</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install numpy</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /workfolder</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./main.py /workfolder/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>,<span class="string">&quot;/workfolder/main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><code>aipline</code>為<code>musl libc</code>的核心，雖然小巧，但有一部份功能受限，若要安裝<code>Python</code>的第三方套件，需要透過<code>UnixCCompiler</code>編譯才可通過</li></ul></li><li><p>建立Python應用鏡像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image build -t 名稱:標籤 .</span><br></pre></td></tr></table></figure><ul><li><code>-t</code>為加標籤</li></ul></li><li><p>運行</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run --rm -it 名稱:標籤`</span><br></pre></td></tr></table></figure><ul><li><code>rm</code>為運行結束後，將container刪除</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.youtube.com/watch?v=MgUV_Alr42g&list=PLliocbKHJNwubNT2oK-xlB1GXTXuLFb0I&index=6">小馬Docker教學</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker學習紀錄-基本概念</title>
      <link href="/larry891001/2022/07/02/docker/docker_Introduce/"/>
      <url>/larry891001/2022/07/02/docker/docker_Introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="何謂虛擬化"><a href="#何謂虛擬化" class="headerlink" title="何謂虛擬化?"></a>何謂虛擬化?</h2><ul><li><p>因為每台電腦的作業系統與硬體配置不盡相同，我的程式可能剛好只跟我電腦上的環境相容。而虛擬化要做的就是模擬出一個環境，讓程式可以在不同硬體上執行時，都以為自己在同一個環境中執行。</p></li><li><p>目前常見用來比較的虛擬化技術有兩種，一種是在系統層級的虛擬化技術，在這我們叫它稱虛擬機器（Virtual machine）。另外一種則是在作業系統層級，此稱容器（Container）。前者的代表如Virtual Box，而後者如Docker。</p></li></ul><h2 id="虛擬機器-v-s-容器"><a href="#虛擬機器-v-s-容器" class="headerlink" title="虛擬機器 v.s. 容器"></a>虛擬機器 v.s. 容器</h2><ul><li><p>虛擬機器（以作業系統為中心）</p><ul><li>虛擬化的目標：將一個應用程式所需的執行環境打包起來，建立一個獨立環境，方便在不同的硬體中移動。<br>虛擬機器是在系統層上虛擬化，透過 Hypervisor 在目標的機器上提供可以執行一個或多個虛擬機器的平台。而這些虛擬機器可以執行完整的作業系統。簡單來說，Hypervisor 就是一個可以讓你在作業系統（Host OS）上面再裝一個作業系統（Guest OS），然後讓兩個作業系統彼此不會打架的平台。</li><li>透過選擇不同的 Guest OS，虛擬機器的技術就可以確保只要我的程式在該 Guest OS 上可以正常運作，那放到你的電腦上跑時，可以不管你的 Host OS 是什麼，只要在你的 Host OS 上先裝上我的 Guest OS，我的程式就可以正常在你的電腦上運作。</li></ul></li><li><p>容器（以應用程式為中心）</p><ul><li>容器化的目標：改善虛擬機器因為需要裝 Guest OS 導致啟動慢、佔較大記憶體的問題。<br>容器是在作業系統層上虛擬化，透過 Container Manager 直接將一個應用程式所需的程式碼、函式庫打包，建立資源控管機制隔離各個容器，並分配 Host OS 上的系統資源。透過容器，應用程式不需要再另外安裝作業系統（Guest OS）也可以執行。</li><li>因為不需要另外安裝作業系統，建立容器所需要的硬碟容量可以大幅降低，且啟動速度可以更快，不需要等待 Guest OS 的開機時間。</li></ul></li></ul><h2 id="為什麼要用Docker"><a href="#為什麼要用Docker" class="headerlink" title="為什麼要用Docker?"></a>為什麼要用Docker?</h2><ul><li>由於傳統虛擬機器(Virtual Machine)因為需要額外安裝作業系統（Guest OS），導致啟動慢、佔較大記憶體的問題</li><li>Docker 要提供的解法以應用程式為核心虛擬化，取代傳統需要 Guest OS 的虛擬化技術</li></ul><h2 id="Docker-三個基本概念"><a href="#Docker-三個基本概念" class="headerlink" title="Docker 三個基本概念"></a>Docker 三個基本概念</h2><ul><li>映像檔（Image）<ul><li>Docker 映像檔就是一個唯讀的模板。</li><li>映像檔可以用來建立 Docker 容器。</li></ul></li><li>容器（Container）<ul><li>容器是從映像檔建立的執行實例。</li><li>Docker 利用容器來執行應用。</li><li>可以被啟動、開始、停止、刪除。</li><li>每個容器都是相互隔離的、保證安全的平台。</li></ul></li><li>倉庫（Repository）<ul><li>倉庫是集中存放映像檔檔案的場所。</li><li>每個倉庫中又包含了多個映像檔。</li><li>每個映像檔有不同的標籤（tag）。</li><li>倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式。</li></ul></li></ul><h2 id="Image-映像檔-常用指令"><a href="#Image-映像檔-常用指令" class="headerlink" title="Image 映像檔 常用指令"></a>Image 映像檔 常用指令</h2><table><thead><tr><th align="left">指令</th><th align="left">說明</th><th align="left">範例</th></tr></thead><tbody><tr><td align="left">search</td><td align="left">搜尋</td><td align="left">docker search centos</td></tr><tr><td align="left">pull</td><td align="left">下載</td><td align="left">docker pull centos</td></tr><tr><td align="left">images</td><td align="left">列表</td><td align="left">docker images</td></tr><tr><td align="left">run</td><td align="left">執行</td><td align="left">docker run -ti centos /bin/bash</td></tr><tr><td align="left">rmi [Image ID]</td><td align="left">刪除</td><td align="left">docker rmi 615cb40d5d19</td></tr><tr><td align="left">build</td><td align="left">建立</td><td align="left">docker build -t member:1 .</td></tr><tr><td align="left">login</td><td align="left">登入</td><td align="left">docker login docker.okborn.com</td></tr><tr><td align="left">push</td><td align="left">上傳</td><td align="left">docker push</td></tr></tbody></table><h2 id="Container-容器-常用指令"><a href="#Container-容器-常用指令" class="headerlink" title="Container 容器 常用指令"></a>Container 容器 常用指令</h2><table><thead><tr><th align="left">指令</th><th align="left">說明</th><th align="left">範例</th></tr></thead><tbody><tr><td align="left">run</td><td align="left">新建或啟動</td><td align="left">docker run -d centos</td></tr><tr><td align="left">start [Contain ID]</td><td align="left">啟動</td><td align="left">docker start a469b9226fc8</td></tr><tr><td align="left">stop [Contain ID]</td><td align="left">停止</td><td align="left">docker stop a469b9226fc8</td></tr><tr><td align="left">rm [Contain ID]</td><td align="left">刪除</td><td align="left">docker rm a4</td></tr><tr><td align="left">ps -a</td><td align="left">列表</td><td align="left">docker ps -a</td></tr><tr><td align="left">logs [Contain ID]</td><td align="left">查看容器內的資訊</td><td align="left">docker logs -f a4</td></tr><tr><td align="left">exec [Contain ID]</td><td align="left">進入容器(開新console)</td><td align="left">docker exec -ti a4 /bin/bash</td></tr><tr><td align="left">attach</td><td align="left">進入容器(退出停止容器)</td><td align="left">dockr attach a4</td></tr><tr><td align="left">inspect</td><td align="left">查看</td><td align="left">docker inspect a4</td></tr></tbody></table><h2 id="Registry-倉庫-常用指令"><a href="#Registry-倉庫-常用指令" class="headerlink" title="Registry 倉庫 常用指令"></a>Registry 倉庫 常用指令</h2><table><thead><tr><th align="left">指令</th><th align="left">說明</th><th align="left">範例</th></tr></thead><tbody><tr><td align="left">commit</td><td align="left">容器存檔</td><td align="left">docker commit db aaa:v1</td></tr><tr><td align="left">pull</td><td align="left">下載</td><td align="left">docker pull docker.okborn.com/okborn:base</td></tr><tr><td align="left">tag</td><td align="left">標籤</td><td align="left">docker tag aaa docker.okborn.com/aaa</td></tr><tr><td align="left">push</td><td align="left">上傳</td><td align="left">docker push docker.okborn.com/member:1</td></tr><tr><td align="left">login</td><td align="left">登入</td><td align="left">docker login docker.okborn.com</td></tr><tr><td align="left">export</td><td align="left">匯出</td><td align="left">docker export 7691a814370e &gt; ubuntu.tar</td></tr><tr><td align="left">import</td><td align="left">匯入</td><td align="left">cat ubuntu.tar sudo docker import - test/ubuntu:v1.0</td></tr></tbody></table><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cwhu.medium.com/docker-tutorial-101-c3808b899ac6">Docker 基礎教學與介紹 101</a><br><a href="https://ithelp.ithome.com.tw/articles/10199339">Docker 基本教學</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts解題紀錄</title>
      <link href="/larry891001/2022/07/01/LeetCode/Mid/1465/"/>
      <url>/larry891001/2022/07/01/LeetCode/Mid/1465/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/">LeetCode - 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要在一個長為<code>h</code>、寬為<code>w</code>，且經過水平及垂直切割過的條件下，找出最大的區域。我先將水平及垂直的切割線由小排到大，然後分別找出每兩條線之間最大的長度，將兩者相乘，就會得到一個最大的區域。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, h: <span class="built_in">int</span>, w: <span class="built_in">int</span>, horizontalCuts: <span class="type">List</span>[<span class="built_in">int</span>], verticalCuts: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        horizontalCuts.sort()</span><br><span class="line">        verticalCuts.sort()</span><br><span class="line">        dif_h,dif_v = horizontalCuts[<span class="number">0</span>],verticalCuts[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(horizontalCuts)-<span class="number">1</span>):</span><br><span class="line">            dif_h = <span class="built_in">max</span>(dif_h,horizontalCuts[i+<span class="number">1</span>]-horizontalCuts[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(verticalCuts)-<span class="number">1</span>):</span><br><span class="line">            dif_v = <span class="built_in">max</span>(dif_v,verticalCuts[i+<span class="number">1</span>]-verticalCuts[i])</span><br><span class="line">            </span><br><span class="line">        dif_v = <span class="built_in">max</span>(w-verticalCuts[-<span class="number">1</span>],dif_v) </span><br><span class="line">        dif_h = <span class="built_in">max</span>(h-horizontalCuts[-<span class="number">1</span>],dif_h) </span><br><span class="line">        <span class="keyword">return</span> (dif_h*dif_v)% <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -136. Single Number解題紀錄</title>
      <link href="/larry891001/2022/07/01/LeetCode/easy/single-number/"/>
      <url>/larry891001/2022/07/01/LeetCode/easy/single-number/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/single-number/">LeetCode - 136. Single Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題要找出只出現過一次的數字，我建立一個<code>dictionary</code>，並直接查找只出現一次的數字</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dic =&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            dic[i] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            dic[i] +=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> dic[i] ==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -1710. Maximum Units on a Truck解題紀錄</title>
      <link href="/larry891001/2022/07/01/LeetCode/easy/maximum-units-on-a-truck/"/>
      <url>/larry891001/2022/07/01/LeetCode/easy/maximum-units-on-a-truck/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/maximum-units-on-a-truck/">LeetCode - 1710. Maximum Units on a Truck</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目給了<code>boxTypes</code>跟<code>TruckSize</code>，他要求的是在<code>TruckSize</code>可以負擔的情況下，最大的<code>Units</code>為多少，每個<code>boxTypes</code>前面的元素為它的<code>box</code>個數，後面的元素為每個<code>box</code>所佔的<code>Units</code>。我先將<code>boxTypes</code>的元素位置調換，因為我想讓他的<code>Units</code>的從大排到小，因為<code>Units</code>大的<code>box</code>一定要先放在卡車上，拿完一組再接一組直到<code>Truck</code>不能再裝為止</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUnits</span>(<span class="params">self, boxTypes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], truckSize: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span>        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> boxTypes:</span><br><span class="line">            i[<span class="number">0</span>],i[<span class="number">1</span>] = i[<span class="number">1</span>],i[<span class="number">0</span>]</span><br><span class="line">        boxTypes.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> boxTypes:</span><br><span class="line">            <span class="keyword">if</span> truckSize &gt; <span class="number">0</span>:</span><br><span class="line">                n = <span class="built_in">min</span>(i[<span class="number">1</span>], truckSize)</span><br><span class="line">                truckSize -= n</span><br><span class="line">                total += i[<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">return</span> total </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>強化學習(Reinforcement Learning)</title>
      <link href="/larry891001/2022/05/30/ML/RL/"/>
      <url>/larry891001/2022/05/30/ML/RL/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="Reinforcement-Learning基礎概念"><a href="#Reinforcement-Learning基礎概念" class="headerlink" title="Reinforcement Learning基礎概念"></a>Reinforcement Learning基礎概念</h2><p><img src="https://miro.medium.com/max/1400/1*SXvCTwCgH_TdnPhe9mBhZw.png" alt="Scenario of Reinforcement Learning"></p><ul><li>Agent</li><li>Environment</li><li>Observation: <code>Observation</code>又稱作<code>State</code>，就是指環境的狀態，也就是Machine所觀察到的東西</li><li>Action: Machine所做出的動作就叫做<code>Action</code>，這些<code>Action</code>會影響<code>environment</code></li><li>Reward: 表示Machine做了<code>Action</code>，所得到的影響</li></ul><p>舉例來說，Machine看到一杯水，並打翻它，那就得到一個負值報酬，而因為水已經被打翻了，因此下一個時間點所看到的就是水被打翻的狀態，這時候它決定把地擦乾淨，因此得到一個正值報酬。</p><div class="note flat"><p>機器學習的目標就是根據過去的經驗讓Reward被最大化的Action。</p></div><h2 id="目前強化學習分成兩大塊："><a href="#目前強化學習分成兩大塊：" class="headerlink" title="目前強化學習分成兩大塊："></a>目前強化學習分成兩大塊：</h2><ul><li>Policy-based<br> 訓練一個負責做事的Actor</li><li>Value-based<br> 訓練一個不做事的Critic</li></ul><h2 id="Three-Steps-for-Deep-Learning"><a href="#Three-Steps-for-Deep-Learning" class="headerlink" title="Three Steps for Deep Learning"></a>Three Steps for Deep Learning</h2><p><img src="https://i.imgur.com/3Mqta3f.png" alt="Steps of Deep Learning"></p><ol><li>定義function<ul><li>NN決定function space</li><li>Actor可以是一個NN<br>  -如果Actor是NN，那就是Deep Reinforcement Learning</li></ul></li><li>決定function的好壞<ul><li>衡量Actor的好壞</li></ul></li><li>選擇最好的Actor<ul><li>利用Gradient Ascent</li></ul></li></ol><h2 id="Neural-network-as-Actor"><a href="#Neural-network-as-Actor" class="headerlink" title="Neural network as Actor"></a>Neural network as Actor</h2><p><img src="http://ai.ntu.edu.tw/aho/JPG/Introduction_of_Reinforcement_Learning/Introduction_of_Reinforcement_Learning_23.jpg" alt="NN as Actor"></p><ul><li>neural network的輸入: 也就是Machine所看到的<code>observation</code>，這<code>observation</code>可以用一個vector或matrix來描述</li><li>neural network的輸出: 現在有幾個可以採取的<code>Action</code>，代表output就會有幾個<code>dimension</code>(Policy Gradient通常假設Actor(Policy)是Stochastic(隨機)，意思就是，Policy的Output是機率，上圖為例，即是70%會left，20%會right，10%會fire。)</li></ul><div class="note flat"><p>相較於傳統作法使用table來記錄Observation與Action的對應，利用NN的優點在於它可以舉一反三，即使沒有看過的畫面，最終還是會有一個輸出。</p></div><h2 id="Goodness-of-Actor"><a href="#Goodness-of-Actor" class="headerlink" title="Goodness of Actor"></a>Goodness of Actor</h2><p><img src="https://i.imgur.com/T83CDO1.png" alt="Goodness of Actor"><br>強化學習中定義Actor的好壞也是類似的方式，Actor就是一個NN，它的參數是θ，因此我們用πθ來表示Actor</p><ul><li>Actor:πθ<ul><li>一個Actor就是一個function</li><li>input：S<ul><li>Actor看到的Observation</li></ul></li><li>Rθ：遊戲結束之後的Total Reward<ul><li>r1+r2…+rT</li><li>Total Reward就是我們要Maximize的對象<ul><li>並非優化每一個step<br>即使相同的Actor，不同的episode也會有不同的結果(每次的<br>Rθ不同)，理由如下：</li></ul></li></ul></li></ul></li></ul><ol><li>Actor採Stochastic，即使看到相同場景、相同參數也會採取不同的Action，因此每次得到的Rθ也不同</li><li>遊戲本身的隨機性，即使採取相同的Action，每次看到的Observation也不一樣，因此，Rθ本身是一個Random-Variable</li></ol><p>我們要做的並不是最大化某一次遊戲得到的Rθ，而是<code>Rθ的期望值</code>。拿同一個Actor玩了N次遊戲之後，我們希望<code>Rθ的期望值</code>愈大愈好。</p><p>這個期望值，就是用來衡量Actor的好壞。</p><h2 id="Gradient-Ascent"><a href="#Gradient-Ascent" class="headerlink" title="Gradient Ascent"></a>Gradient Ascent</h2><p><img src="https://i.imgur.com/bt1JJ7p.png" alt="Gradient Ascent"><br>我們的目標函數(Objective Function)就是找一個參數來最大化<br>¯Rθ，解法就是利用Gradient Ascent(因為我們要最大化)。</p><p>作法如下：</p><ol><li>隨機初始θ0</li><li>計算使用θ0的Actor，θ0對¯Rθ0的微分</li><li>更新參數得到θ1</li><li>計算θ1對¯Rθ1的微分</li><li>更新參數得到θ2</li><li>…</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://hackmd.io/@shaoeChen/By4AiVywN?type=view">李宏毅_ML</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> RL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遞迴神經網路(recurrent neural networks，RNN)</title>
      <link href="/larry891001/2022/05/28/ML/RNN/"/>
      <url>/larry891001/2022/05/28/ML/RNN/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>建立語言的相關模型，如果能額外考慮上下文的關係，準確率就會顯著提高，因此，學者提出『循環神經網路』(Recurrent Neural Network, RNN)演算法，它是『自然語言處理』領域最常使用的Neural Network模型，簡單的RNN模型(Vanilla RNN)額外考慮前文的關係，他是一種專門設計來解決時間相關問題的神經網路(note: 時間相關問題，就是當下的答案會受過去的答案影響，而且也會影響未來的答案的一種特殊情況。也可以說是次序相關問題。)，RNN主要是透過將隱藏層的output存在Memory裡，當下次input資料進去train的時候，會同時考慮上一次存在Memory裡的值進行計算。</p><div class="note modern simple"><p>而只要答案有所謂的時間相關性，那他就是一個時間相關問題，可以用RNN來解決。</p></div><p>下圖所示為Simple-RNN的神經網路示意圖。神經網路為A，通過讀取某個時間(狀態)的輸入xt，然後輸出一個值ht，循環可以使得信息從當前時間步傳遞到下一時間步。<br>這些循環使得RNN可以被看作同一網路在不同時間步的多次循環，每個神經元會把更新的結果傳遞給下一個時間步，下圖右側即為循環展開的情形。<br><img src="https://4.bp.blogspot.com/-U-b50pPNd_s/WQ8C-5g0siI/AAAAAAAAI8c/VCpWPA-z3Y8iTvLIhX6hlO83BqogFMu5ACLcB/s640/RNN2.png" alt="圖一"><br> 下圖為網路的某一時刻輸入xt，xt是一個n維的向量，RNN的輸入是一整個序列，也就是X=[x0,x1,..xt-1,xt,xt+1,…xT]，對於語言模型，每一個xt將代表一個詞向量，一整個序列就代表一句話。ht代表時刻t的隱含狀態，yt代表時刻t的輸出。</p><p>輸入層到隱含層權重由U表示，它將原始輸入進行抽象作為隱含層的輸入。<br>隱含層到隱含層的權重為W，它是網路的記憶控制者，負責調度記憶。<br>隱含層到輸出層的權重為V，從隱含層學習到的表示將通過它再一次抽象，並作為最終輸出。</p><p>前向傳播(Forward Propagation) 依次按照時間的順序計算一次即可，反向傳播(Back Propagation)從最後一個時間將累積的殘差傳遞回來即可，跟普通的BP神經網路訓練本質上基本一樣，由於加入了時間順序，計算方式有所不同，這稱之為BPTT(Back Propagation Through Time)算法<br><img src="https://3.bp.blogspot.com/-9cz6YIf-3Wk/WQ8C-7QNnOI/AAAAAAAAI8g/iFhXR9t3ii0UE9ZRXs425wR_HYJk9i7WgCLcB/s1600/RNN1.png" alt="圖二"></p><h2 id="各種類型RNN"><a href="#各種類型RNN" class="headerlink" title="各種類型RNN"></a>各種類型RNN</h2><ul><li>依據 input 及 output 的數目，RNN 可以有很多的變化與應用：<ol><li>一對一(one to one)：固定長度的輸入(input)及輸出(output)，即一般的 Neural Network 模型。</li><li>一對多(one to many)：單一輸入、多個輸出，例如影像標題(Image Captioning)，輸入一個影像，希望偵測影像內多個物體，並一一給予標題，這稱之為『Sequence output』。</li><li>多對一(many to one)：多個輸入、單一輸出，例如情緒分析(Sentiment Analysis)，輸入一大段話，判斷這段話是正面或負面的情緒表達，這稱之為『Sequence input』。</li><li>多對多(many to many)：多個輸入、多個輸出，例如語言翻譯(Machine Translation)，輸入一段英文句子，翻譯成中文，這稱之為『Sequence input and sequence output 』。</li><li>另一種多對多(many to many)：『同步』(Synchronize)的多個輸入、多個輸出，例如視訊分類(Video Classification)，輸入一段影片，希望為每一幀(Frame)產生一個標題，這稱之為『Synced sequence input and output』。</li></ol></li></ul><p><img src="https://ithelp.ithome.com.tw/upload/images/20171210/200019764hsWa3ZvMN.jpg" alt="type of RNN"></p><h2 id="BPTT與梯度消失"><a href="#BPTT與梯度消失" class="headerlink" title="BPTT與梯度消失"></a>BPTT與梯度消失</h2><p>RNN所使用的訓練方法並不是像DNN所提到的反向傳播法(BP, Back Propagation)，而是進階版本的BPTT，因此很容易梯度消失。梯度消失是一種在訓練的時候因為梯度歸零而發現訓練沒有效果的情況。與BP不同的地方就在於BPTT是透過時間來進行訓練的。</p><div class="note modern simple"><p>那為什麼要透過時間來進行訓練呢？</p></div><p>hidden state它是用來儲存歷史訊息的小房間，而神經元會透過這些歷史訊息在特徵(權重)已經被固定的情況下，得出與時間相關的對應答案。所以其實歷史訊息和應該出現的答案之間的關係是需要被訓練的，這就是為什麼我們需要BPTT。</p><p>那為什麼RNN做BPTT會容易出現梯度消失呢？</p><div class="note modern simple"><p>因為歷史資訊太長了。</p></div><p>首先，梯度消失是因為對參數連續進行偏微分而導致數值爆炸性的縮小。你可以簡單想像是係數相乘而導致數值不斷趨近於零。</p><p>比方說，我們有那經典的一句<code>To be or not to be, that&#39;s the question.</code>。很顯然，單字的出現是一個時間相關問題(次序相關)。那麼我們應該可以用RNN來訓練。</p><p>但是如果想要學習單字跟單字之間的關係並沒有那麼容易，只是<code>To</code>跟<code>be</code>大概沒什麼問題，我們使用反向傳播訓練，只要對歷史資訊偏微分一次就可以找到他們在歷史資訊上的相關性。<br>但是<code>To</code>跟<code>question</code>呢？反向傳播法會需要連續的進行偏微分來找到<code>To</code>跟<code>question</code>之間的關係，但連續的偏微分就會導致梯度消失，這讓我們很難找到他們之間的關係。</p><p>所以在對歷史資訊做反向傳播法的時候，很容易會遇到很嚴重的梯度消失問題，你壓根沒辦法讓神經元透過hidden state的變化來找出應該有的輸出。<br>那怎麼辦呢？這裡要出動我們的救星LSTM和GRU。</p><h2 id="LSTM和GRU"><a href="#LSTM和GRU" class="headerlink" title="LSTM和GRU"></a>LSTM和GRU</h2><ol><li><p>LSTM(Long short-term memory)<br>LSTM比起原來單純的hidden state小房間，他多了三個門(gate)，分別是Input gate(輸入門)，Forget gate(遺忘門)，和Output gate(輸出門)。<br>輸入門： 決定這一次的輸入需不需要被記憶，或者要記多少(可能只有記個三成)<br>遺忘門： 決定要不要遺忘之前的hidden state，也可以按比例遺忘。<br>輸出門： 決定這一次所得到的輸出要放多少(也是比例)進去hidden state小房間。<br>這三個門的合作可以讓某些不重要單字被忽略，進而讓梯度可以順利進行遠距離的傳遞，進而完成訓練。<br>而且由於hidden state來自三個門的線性運算，這讓hidden state與歷史資訊之間呈現線性而非乘積的關係，從而避免了梯度消失。<br><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119971ToTCRtVWSu.png" alt="LSTM"></p></li><li><p>GRU(Gated recurrent unit)<br>接下來是GRU，GRU有兩個門，Reset Gate(重製門)和Update Gate(更新門)。<br>重製門： 決定是否要遺忘之前留下來的hidden state。<br>更新門： 決定這一次的hidden state所要留下來的比例。<br>所以GRU也是透過兩個門之間的線性運算來產生hidden state，這使的GRU的hidden state與歷史資訊之間同樣變成線性關係，進而避免了梯度消失。</p></li></ol><h2 id="三者比較"><a href="#三者比較" class="headerlink" title="三者比較"></a>三者比較</h2><p><img src="https://i0.wp.com/clay-atlas.com/wp-content/uploads/2020/06/rnn-family.png?w=884&ssl=1" alt="threeCompare"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://medium.com/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E7%9F%A5%E8%AD%98%E6%AD%B7%E7%A8%8B/rnn-%E9%81%9E%E8%BF%B4%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-%E5%85%A8%E9%9D%A2%E8%AA%8D%E8%AD%98-27e4dd150bdd">RNN(遞迴神經網路)全面認識</a><br><a href="https://ithelp.ithome.com.tw/articles/10193469">Day 14：循環神經網路(Recurrent Neural Network, RNN)</a><br><a href="https://arbu00.blogspot.com/2017/05/3-rnn-recurrent-neural-networks.html">深度學習(3)–循環神經網絡(RNN, Recurrent Neural Networks)</a><br><a href="https://ithelp.ithome.com.tw/articles/10223055">[Day-16] RNN - LSTM介紹</a><br><a href="https://ithelp.ithome.com.tw/articles/10194201">Day 17：GRU (Gated Recurrent Unit) 概念介紹與實作</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然語言處理(NLP)</title>
      <link href="/larry891001/2022/05/28/ML/NLP/"/>
      <url>/larry891001/2022/05/28/ML/NLP/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="『自然語言處理』-NLP"><a href="#『自然語言處理』-NLP" class="headerlink" title="『自然語言處理』(NLP)"></a>『自然語言處理』(NLP)</h2><ul><li>讓電腦擁有理解人類語言的能力，就是自然語言處理 (Natural Language Processing，縮寫 NLP)。</li><li>主要範疇:<ol><li>文本朗讀（Text to speech）/ 語音合成（Speech synthesis）</li><li>語音識別（Speech recognition）</li><li>自動分詞（word segmentation）</li><li>詞性標註（Part-of-speech tagging）</li><li>句法分析（Parsing）</li><li>自然語言生成（Natural language generation）</li><li>文本分類（Text categorization）</li><li>信息檢索（Information retrieval）</li><li>信息抽取（Information extraction）</li><li>文字校對（Text-proofing）</li><li>問答系統（Question answering）</li><li>機器翻譯（Machine translation）</li><li>自動摘要（Automatic summarization）</li><li>文字蘊涵（Textual entailment）</li></ol></li></ul><h2 id="語文的特性"><a href="#語文的特性" class="headerlink" title="語文的特性"></a>語文的特性</h2><p>影像相對於語文來說非常單純，人類的語言具高度曖昧性，一句話可能有不同的的意思或是隱喻，且隨著時代演進不斷變化，新詞會不斷的被創造出來，語言學家越來越難建立規則(文法及語意學)來規範語文。另外，由於語文的不規則性，在放入模型解析之前，我們通常會先對輸入的語文做前置處理(Preprocess)，包括：</p><ol><li><p>資料清理(Data Cleaning)：例如我們抓網頁資料，必須先清除 HTML 標籤(Tag)，取出乾淨的本文。</p></li><li><p>標點符號(Punctuation)：對語意沒有影響，通常會忽略他們。</p></li><li><p>分詞(Tokenize)：英文較容易，一般以空白即可，但中文就比較困難。</p></li><li><p>Stop Words：例如英文的『the』、『as』、『to』、『from』…等介係詞或助詞，他們對語文大意的瞭解可能沒有太大的幫助，通常會忽略他們。</p></li><li><p>『詞嵌入』(Word Embedding)：要交給電腦計算，將單字轉數值會比較容易處理，『詞嵌入』技術通常會將單字轉為實數，以形成連續的向量空間，比較有名的模型包括Word2Vec 及 GloVe。</p></li><li><p>相似詞整理：意義相近的單字或片語，在解析字句及分類時必須能呈現出來，Google Tomas Mikolov 創造 Word2Vec 模型，以向量(Vector)空間來定義單字(Word)。</p></li><li><p>『語料庫』(Corpus)：要能訓練模型，必須要有大量的標註資料，NLTK(Natural Language Toolkit)工具箱同時提供完整的函數庫及大量的語料庫，各式的語料庫可透過下列指令下載：</p><ul><li>安裝 NLTK 函數庫<br>pip install -U nltk</li><li>在DOS內輸入Python<br>import nltk<br>nltk.download()<br>或直接下載全部語料庫:<br>python -m nltk.downloader all</li></ul></li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>要理解一段話，首先要從單字開始，進而到片語(Phrase)、句子(Sentence)，加上文法(Syntax)、語意(Semantics)解析，我們才能理解這一段話的意義，如果要從這樣的導向(Approach)出發，我們可能要聘請語言學專家建置龐大的『規則引擎』(Rule Engine)才行，工程浩大，所費不貲，維護成本可能也是天文數字，反之，從另一種角度思考，可否與CNN一樣，改為提供大量字句，讓機器自我學習 ?<br>如果，我們把字句當作input，餵入Neural Network模型，希望機器產生適當的回應，會有幾個問題要解決：</p><ul><li>字句有長有短，即 input 變數數目不等，回應也是一樣的狀況，output 變數數目也不等。</li><li>語文會有上下文的關係，斷章取義，常會扭曲全文代表的意義。</li><li>人類擁有記憶力，對某些人、事、物會有深度的連結，講到『川普』，可能會想到『北韓』，若機器擁有記憶力機制，預測準確率就會高很多。</li><li>針對以上的語文特性，學者提出三個解決問題的演算法，分別為『循環神經網路』(Recurrent Neural Network, RNN)、長短期記憶網路(Long Short Term Memory Network, LSTM)及 GRU (Gated Recurrent Unit)</li></ul><h3 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h3><p><a href="http://localhost:4000/larry891001/2022/05/28/ML/RNN/">RNN</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ithelp.ithome.com.tw/articles/10193224">自然語言處理</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -3. Longest Substring Without Repeating Characters解題紀錄</title>
      <link href="/larry891001/2022/05/28/LeetCode/Mid/LongestSubstringWithoutRepeatingCharacters/"/>
      <url>/larry891001/2022/05/28/LeetCode/Mid/LongestSubstringWithoutRepeatingCharacters/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">LeetCode - 3. Longest Substring Without Repeating Characters</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要找出最長的不重複字母的子字串，首先，先建立一個起點<code>start</code>、最長字串長度<code>maxlength</code>和一個字典紀錄用過的字母<code>usedChar</code>，然後開始遍歷字串。如果這個字母是使用過的而且他在起點之後，就把起點移到曾使用過字母的下一個位置，然後去計算長度，並更新字典，直到遍歷完成。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        start = maxlength = <span class="number">0</span></span><br><span class="line">        usedChar = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">                start = usedChar[s[i]]+<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            maxlength = <span class="built_in">max</span>(maxlength,i-start+<span class="number">1</span>)    </span><br><span class="line">            usedChar[s[i]] = i</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -2. Add Two Numbers解題紀錄</title>
      <link href="/larry891001/2022/05/27/LeetCode/Mid/AddTwoNums/"/>
      <url>/larry891001/2022/05/27/LeetCode/Mid/AddTwoNums/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">LeetCode - 2. Add Two Numbers</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題題目是要將兩串<code>Linked-list</code>去做十進位的加法，每個<code>Linked-list</code>的頭都是個位數字，它的下一個就是十位數字…以此類推。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        l1_size=<span class="number">0</span></span><br><span class="line">        tmp_l1 = l1</span><br><span class="line">        <span class="keyword">while</span> tmp_l1:</span><br><span class="line">            l1_size += <span class="number">1</span></span><br><span class="line">            tmp_l1 = tmp_l1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        l2_size=<span class="number">0</span></span><br><span class="line">        tmp_l2 = l2</span><br><span class="line">        <span class="keyword">while</span> tmp_l2:</span><br><span class="line">            l2_size += <span class="number">1</span></span><br><span class="line">            tmp_l2 = tmp_l2.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        temp = l1 <span class="keyword">if</span> l1_size &gt;= l2_size <span class="keyword">else</span> l2</span><br><span class="line">            </span><br><span class="line">        skr = temp</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            temp.val = l1.val + l2.val</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        skr1 = skr</span><br><span class="line">        <span class="keyword">while</span> skr:</span><br><span class="line">            <span class="keyword">if</span> skr.val &gt;= <span class="number">10</span>:</span><br><span class="line">                skr.val -= <span class="number">10</span></span><br><span class="line">                <span class="keyword">if</span> skr.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">                    skr.<span class="built_in">next</span> = ListNode()</span><br><span class="line">                skr.<span class="built_in">next</span>.val += <span class="number">1</span></span><br><span class="line">            skr = skr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> skr1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -1342. Number of Steps to Reduce a Number to Zero 解題紀錄</title>
      <link href="/larry891001/2022/05/26/LeetCode/easy/StepsToReduceZero/"/>
      <url>/larry891001/2022/05/26/LeetCode/easy/StepsToReduceZero/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/">LeetCode - 1342. Number of Steps to Reduce a Number to Zero</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題十分簡單，判斷一個數字減少到0所需要的步數，如果該數字是偶數就除上2，若是奇數就減去1，直到變成0</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSteps</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">                num/=<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num-=<span class="number">1</span></span><br><span class="line">            step +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷積神經網路(Convolutional neural network, CNN)</title>
      <link href="/larry891001/2022/05/25/ML/CNN/"/>
      <url>/larry891001/2022/05/25/ML/CNN/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="Pixels-in-Image"><a href="#Pixels-in-Image" class="headerlink" title="Pixels in Image"></a>Pixels in Image</h2><ul><li>一張圖片包含許多Pixels(像素)</li><li>每個像素包含了RGB三種通道</li><li>每個通道有0-255的brightness levels(亮度)</li></ul><h2 id="CNN過程"><a href="#CNN過程" class="headerlink" title="CNN過程"></a>CNN過程</h2><ul><li>整個CNN結構主要分成幾個部分 : 卷積層 ( Convolution layer )、池化層 (Pooling layer) 以及最後一個全連接層 ( Fully Connected layer )。<br><img src="https://i.imgur.com/77bPBr3.png" alt="CNN過程"></li></ul><h2 id="CNN基礎介紹-卷積運算-Convolution"><a href="#CNN基礎介紹-卷積運算-Convolution" class="headerlink" title="CNN基礎介紹-卷積運算(Convolution)"></a>CNN基礎介紹-卷積運算(Convolution)</h2><ul><li><p><code>Extract some features</code> on specific local area</p></li><li><p>濾波影像 = 影像*filter (note: * 不是乘號是卷積運算)</p></li><li><p>對每個像素做卷積運算，圖片中紅色框起來的部份會和filter進行點跟點相乘，最後在全部相加得到結果，這個步驟就是卷積運算。</p></li><li><p>一般在影像上，卷積運算後會再加上激活函數(activation function)，進行非線性轉換，之後得到的圖片會稱為特徵圖(feature map)。</p></li><li><p>Feature map{i} = original Data * Kernel Map{i} (note: 卷積運算的mask一般稱為kernel map)<br><img src="https://miro.medium.com/max/1400/1*5hYR5abQS_wwOtBTzh3ggA.png" alt="Convolution"></p></li><li><p>Note</p><ul><li>濾波完，圖會變小。這時可以利用zero padding等方式不讓圖片在濾波完變小，比如先將10x10的圖擴大到12x12其他部份先塞0進去，在進行一次卷積運算得到10x10的圖。</li><li>Convolution部份會有一個參數叫strides可以設定filter一次移動幾格。</li></ul></li></ul><h2 id="CNN基礎介紹-池化-Pooling"><a href="#CNN基礎介紹-池化-Pooling" class="headerlink" title="CNN基礎介紹-池化(Pooling)"></a>CNN基礎介紹-池化(Pooling)</h2><ul><li>池化目的只是在將圖片資料量減少並保留重要資訊的方法，把原本的資料做一個最大化或是平均化的降維計算。</li><li>Pooling方法: Max,Mean,Min Pooling</li><li>通常會採用Max Pooling，Max Pooling的概念很簡單只要挑出矩陣當中的最大值就好，Max Pooling主要的好處是當圖片整個平移幾個Pixel的話對判斷上完全不會造成影響，以及有很好的抗雜訊功能。<br><img src="https://miro.medium.com/max/1400/1*bVrG5TXp04cZ8FI77xBUVA.png" alt="pooling"></li><li>Note<ul><li>圖的大小很容易因為pooling變得很小，2x2的Pooling會讓圖小一半，3x3的pooling小3分之1。所以跟卷積運算一樣，Pooling也可以用zero padding和strides的方式，讓圖不要一次變太小。</li></ul></li></ul><h2 id="CNN基礎介紹-全連接-Fully-Connected"><a href="#CNN基礎介紹-全連接-Fully-Connected" class="headerlink" title="CNN基礎介紹-全連接(Fully Connected)"></a>CNN基礎介紹-全連接(Fully Connected)</h2><ul><li>因為做完卷積運算和池化法後得到的特徵圖還是一個2D的圖片，到全連接層前要先轉成1D的陣列。基本上全連接層的部分就是將之前的結果平坦化之後接到最基本的神經網絡了<!-- ![Not Fully-connected](https://img.onl/32h1Is) --></li><li>卷積神經網路實線的重點之一就是權重共享(Shared Weight)，當我們進行 filter 滑動的時候，也是表示我們同一組權重正作用在不同區域，這樣的過程我們這個filter並沒有改變，也就是權重是不會變動的。<br><img src="https://img.onl/neRXL0" alt="Fully-conntected"></li></ul><h2 id="Famous-CNN-Model"><a href="#Famous-CNN-Model" class="headerlink" title="Famous CNN Model"></a>Famous CNN Model</h2><ol><li>LeNet<ul><li>CNN的父親<br><img src="https://img.onl/vrduR3" alt="LeNet"></li></ul></li><li>AlexNet<ul><li>使用<code>ReLU</code>作為激活函數</li><li>提出<code>dropout</code>避免Overfitting</li><li>使用<code>Max Pooling</code>，而不是Mean Pooling</li><li>使用<code>Local Response Normalization(LRN)</code>建立區域性神經元的競爭機制，強化response較大的神經元，抑制response較小的神經元</li><li>由於運算資源通常不夠，所以使用兩張GPU來加速運算</li><li>在資料集中進行資料增量<br><img src="https://img.onl/3XLlgs" alt="AlexNet"></li></ul></li><li>VGG<ul><li>VGG最重要的概念就是使用大量的 3x3 Conv<br>  – 作者認為將較大的Conv抽換成較小的Conv可以將information量提高</li><li>使用較多的較小的Conv比大的Conv可以減少參數</li><li>作者認為2X2 pooling可得到更多的資訊量，因此相較AlexNet 3X3 pooling，VGG改用更小的pooling，並不會overlap</li><li>VGG在training以及testing資料上有做一些不一樣的處理</li><li>Training的部分有使用Multiple scale training。<ul><li>在每次training時，從一個固定的亂數範圍中，random一個數字，並縮放至那個數字，並隨機剪裁成所需大小。</li></ul></li><li>Testing使用多個crop進行預測<ul><li>將資料rescale成一個大小，利用固定的crop大小預測左上、右上、左下、右下跟中間，平均成最後預測結果。</li></ul></li><li>VGG實驗證明<ol><li>Deeper &gt; shallow</li><li>加入LRN會降低準確率</li><li>加入1x1 Conv可提高準確度</li><li>當模型越深，資料耗損越來越高(Gradient Vanishing)，導致後面幾層無法學習出好結果，<code>ResNet</code>有解決這項問題。</li></ol></li></ul></li><li>GoogleNet<ul><li>Inception模組: 在GoogleNet中被提出的新架構，因此GoogleNet又被稱為”Inception Network”</li><li>Filter size往往不知道要設定多少，因此GoogleNet在<br>網路中結合不同的filter來解決filter設定的問題。</li><li>先通過1x1 Conv來達到降維和減少參數。</li><li>可以更好的控制參數<ul><li>移除了全連接網路，直接連結softmax。</li><li>參數數量是AlexNet的一半。</li></ul></li></ul></li><li>ResNet<ul><li>利用<code>捷徑</code>解決退化議題，使深度網路得以實行<br><img src="https://img.onl/LmGLC" alt="Shortcut"></li></ul></li></ol><h2 id="1x1卷積"><a href="#1x1卷積" class="headerlink" title="1x1卷積"></a>1x1卷積</h2><ul><li>1×1 Conv<ul><li>把輸入的圖裡面的值做放大或是縮小</li><li>感覺沒什麼用，的確沒什麼用，但1×1捲積真的用途重點不是在作卷積這件事情。</li></ul></li><li><code>1×1的Conv可以拿來做降維或是升維</code><br><img src="https://miro.medium.com/max/1400/1*4lAta21xehyI92SKzm00PQ.png" alt="1x1"></li><li>1×1 卷積還可以減少訓練參數<ul><li>Example:<br>  input的大小為100x100x56，如果我們做一個有125個filter的5x5卷積層之後(stride = 1 ,pad = 2)，輸出將為 96x96x125<br>  參數: <code>56*5*5*125 = 175000</code><br>  如果我們先經過28個filter的1x1的卷積，再經過有125個filter的5x5卷積層之後，輸出一樣為96x96x125<br>  參數: <code>56*1*1*28+28*5*5*125=89068</code><br>  相對少了快一半的參數</li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>卷積神經網路中的「卷積」就是特徵擷取的方法，此部份必須靠大量資料的特性不斷的反覆學習，在學習中盡可能滿足設立的條件，達到目標。所以在用深度學習時通常希望訓練樣本數可以非常大，這樣電腦在學習Kernel map時才能靠著的optimizer(通常用Stochastic Gradient Descent，SGD)利用倒傳遞(backpropagation)學習更有效得到適合的答案。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://hackmd.io/@allen108108/rkn-oVGA4">卷積神經網路 (Convolutional Neural , CNN)</a></li><li><a href="https://brohrer.mcknote.com/zh-Hant/how_machine_learning_works/how_convolutional_neural_networks_work.html">卷積神經網路的運作原理</a></li><li><a href="https://chih-sheng-huang821.medium.com/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-convolutional-neural-network-cnn-cnn%E9%81%8B%E7%AE%97%E6%B5%81%E7%A8%8B-ecaec240a631">卷積神經網路(Convolutional neural network, CNN) — CNN運算流程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -36. Valid Sudoku解題紀錄</title>
      <link href="/larry891001/2022/05/25/LeetCode/Mid/Valid_sudo/"/>
      <url>/larry891001/2022/05/25/LeetCode/Mid/Valid_sudo/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/valid-sudoku/">LeetCode - 36. Valid Sudoku</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題題目是要檢查是否為「合法」的數獨，而規則就是每一列、每一行以及每個3*3的九宮格內都只含有1-9不重複的數字</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">l</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            s = <span class="built_in">set</span>(l)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> l.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#橫列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> board:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#直列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">                tmp.append(board[j][i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(tmp):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#3*3</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; <span class="number">7</span>:</span><br><span class="line">            save =[]</span><br><span class="line">            save1=[]</span><br><span class="line">            save2=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, l+<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    save.append(board[i][j])</span><br><span class="line">                    save1.append(board[i][j+<span class="number">3</span>])</span><br><span class="line">                    save2.append(board[i][j+<span class="number">6</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(save):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(save1):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(save2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l += <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Confusion Matrix</title>
      <link href="/larry891001/2022/04/09/ML/Confusion/"/>
      <url>/larry891001/2022/04/09/ML/Confusion/</url>
      
        <content type="html"><![CDATA[<h1 id="Confusion-Matrix-混淆矩陣"><a href="#Confusion-Matrix-混淆矩陣" class="headerlink" title="Confusion Matrix(混淆矩陣)"></a>Confusion Matrix(混淆矩陣)</h1><table><thead><tr><th align="center"></th><th align="center">「真實情況」為真</th><th align="center">「真實情況」為非</th></tr></thead><tbody><tr><td align="center">「模型預測」為真(positive)</td><td align="center">true positive(TP)</td><td align="center">false positive(FP)</td></tr><tr><td align="center">「模型預測」為非(negative)</td><td align="center">false negative(FN)</td><td align="center">true negative(TN)</td></tr></tbody></table><ul><li>前面的True和False代表預測本身的結果是正確還是不正確</li><li>而後面的Positive和Negative則是代表預測的方向是正向還是負向的。</li></ul><h2 id="Accuracy、Precision、Recall指標"><a href="#Accuracy、Precision、Recall指標" class="headerlink" title="Accuracy、Precision、Recall指標"></a>Accuracy、Precision、Recall指標</h2><ul><li>Accuracy= (TP+TN)/(TP+FP+FN+TN)<ul><li>所有情形下判斷正確有多少</li><li>在實際正向的情況很少時會失效，如信用卡盜刷，模型可輕易達99%以上</li></ul></li><li>Recall(召回率) = TP/(TP+FN) <ul><li>在實際情形為正向的狀況下，預測「能召回多少」實際正向的答案</li><li>信用卡盜刷</li></ul></li><li>Precision(準確率) = TP/(TP+FP) <ul><li>在預測正向的情形下，實際的「精準度」是多少</li><li>門禁系統</li></ul></li></ul><h2 id="延伸指標"><a href="#延伸指標" class="headerlink" title="延伸指標"></a>延伸指標</h2><p>上述有三種指標，但我們要如何評估哪項指標比較重要呢?<br><img src="https://www.nightynight.info/img/article/classification/24.png" alt="F-measure"></p><ul><li>B=1時的特例 =&gt; F1-score<ul><li>代表Precision和Recall都同等重要，採用F1-Score</li><li>F1-score = 2 * Precision * Recall / (Precision + Recall)</li></ul></li><li>若是precision比較重要，B小一點</li><li>若是recall比較重要，B大一點</li><li>B=0時，即為precision</li><li>B無限大時，即為recall</li></ul><h2 id="多元分類模型指標"><a href="#多元分類模型指標" class="headerlink" title="多元分類模型指標"></a>多元分類模型指標</h2><ul><li><p>對於二元分類，我們可以著重在positive class (例如垃圾信件、有癌症等)，關注positive class的分數</p></li><li><p>但是對於多元分類，對於recall, precision以及f1 score，<br>我們則可以看recall, precision, f1 score的macro, micro and weighted average </p></li><li><p>這些指標將有助於選擇出最好的模型</p><ul><li><p>average = micro<br>  將所有類別看成一個類別，直接計算recall, precision, f1-score</p></li><li><p>average = macro<br>  會對各類別計算各自的recall, precision, f1-score，再計算他們的平均</p></li><li><p>average = weighted<br>  因爲macro會有樣本數不平衡問題，因此在計算出各自的recall, precision, f1-score後，對各類別給予權重，再計算平均</p></li></ul></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="https://img.onl/otEsi4" alt="example"></p><ul><li>Accuracy = (5+6+2)/25   = 13/25</li><li>Recall for class B      = 6/(2+6) = 3/4</li><li>Precision for class B   = 6/(2+6+2) = 3/5</li><li>Micro-Average Recall    = (5+6+2)/((5+6+2)+(5+4+3))<br>sum up the individual class’s <code>TP</code>, <code>FP</code>,and <code>FN</code> of the system for different sets and then apply them to get the score</li><li>Marco-Average Recall    = (0.5+0.75+0.29)/3 =0.513<br>The mean of the recalls of classes A, B and C </li><li>Weighted-Average Recall =  (10*0.5+8*0.75+7*0.29)/25 = 0.5212<br>The sum of the scores of all classes after multiplying their respective class proportions.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Confusion Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Machine Learning Model</title>
      <link href="/larry891001/2022/04/09/ML/BasicMLmodel/"/>
      <url>/larry891001/2022/04/09/ML/BasicMLmodel/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="classification"><a href="#classification" class="headerlink" title="classification"></a>classification</h2><p>監督式學習最常處理的兩個問題：迴歸、分類。當你預測的目標為連續的值，我們稱其為迴歸；若目標為離散的，稱其為分類。<br>常見的演算法：決策樹、邏輯迴歸、SVM（支援向量機）、樸素貝葉斯、kNN</p><h1 id="Decision-Tree-決策樹"><a href="#Decision-Tree-決策樹" class="headerlink" title="Decision Tree(決策樹)"></a>Decision Tree(決策樹)</h1><p>決策樹會根據訓練資料產生一棵樹，依據訓練出來的規則來對新樣本進行預測。決策樹演算法可以使用不同的方式來評估分枝的好壞(亂度)，例如像是Information gain、Gain ratio、Gini index。依據訓練資料找出合適的規則，最終生成一個規則樹來決策所有事情，其目的使每一個決策能夠使訊息增益最大化。就好比我們評估今天比賽是否舉行，天氣因子可能佔比較大的因素，而Co2的濃度高低可能佔的因子程度較低。因此在第一層的決策中以天氣的特徵先進行第一次的決策判斷。接著第二層再從所有特徵中尋找最適合的決策因子，直到設定的最大樹的深度即停止樹的生長。<br><img src="https://ithelp.ithome.com.tw/upload/images/20210924/201072476CHqRkXf16.png" alt="Decision Tree"></p><h2 id="決策樹如何生成"><a href="#決策樹如何生成" class="headerlink" title="決策樹如何生成?"></a>決策樹如何生成?</h2><p>決策樹是以一個<code>Greedy Algorithm</code>來決定每一層要問什麼問題，目標是分類過後每一群能夠很明顯的知道是屬於哪一種類別。延續上面的例子，以分類問題來說假設要評估明天比賽是否舉行。在樹的第一層節點中我們要從已知的兩個特徵分別是溫度與特徵選一個作為該層的決策因子。假設目前訓練集有五筆資料，其中正常舉行的有兩筆資料，取消舉行的有三筆資料。在樹的結構中左子樹為決策正常舉行，而右子樹是決策取消舉行。我們可以發現當特徵為天氣的時候可以一很清楚的將這兩類別完整分開，因此我們會將天氣作為這一層判斷的因子。這就是決策樹在生成中的貪婪機制。然而要如何去判斷每次決策的好壞，就必須依靠亂度的評估指標。<br><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247ZEfzbnhMZY.png" alt="Example"></p><h2 id="決策樹何時停止生長"><a href="#決策樹何時停止生長" class="headerlink" title="決策樹何時停止生長"></a>決策樹何時停止生長</h2><ul><li> All samples for a given node belong to the same class</li><li> There are no remaining attributes for further partitioning – majority<br>voting is employed for classifying the leaf</li><li> There are no samples left</li></ul><h2 id="決策樹的建構議題"><a href="#決策樹的建構議題" class="headerlink" title="決策樹的建構議題"></a>決策樹的建構議題</h2><ol><li>分裂的準則 Split criterion (goodness function)<ul><li>used to select the attribures to be split at a tree node during the tree generation phase<br>different algorithms may use different goodness functions:<ul><li>information gain used in ID3/C4.5</li><li>Gini index used in CART</li></ul></li></ul></li><li>分枝的方案 Branch scheme<ul><li>determining the tree branch to which a sample belongs</li><li>binary or k-ary splitting</li></ul></li><li>何時停止分枝<ul><li>impurity measure</li></ul></li><li>訂定標籤的規則<ul><li>a node is labeled as the class to which most samples at the node belongs</li></ul></li></ol><h2 id="決策樹的混亂評估指標"><a href="#決策樹的混亂評估指標" class="headerlink" title="決策樹的混亂評估指標"></a>決策樹的混亂評估指標</h2><p>我們需要客觀的標準來決定決策樹的每個分支，因此我們需要有一個評斷的指標來協助我們決策。決策樹演算法可以使用不同的指標來評估分枝的好壞，常見的決策亂度評估指標有 Information gain、Gain ratio、Gini index。我們目標是從訓練資料中找出一套決策規則，讓每一個決策能夠使訊息增益最大化。以下的指標都是在衡量一個序列中的混亂程度，其數值越高代表越混亂。然而在 Sklearn 套件中預設使用 Gini。</p><ul><li>Information gain (資訊獲利)</li><li>Gain ratio (吉尼獲利)</li><li>Gini index (吉尼係數) = Gini Impurity (吉尼不純度)</li></ul><h2 id="評估資訊分割量"><a href="#評估資訊分割量" class="headerlink" title="評估資訊分割量"></a>評估資訊分割量</h2><ul><li>由於我們希望獲得的資訊量要最大，因此經由分割後的資訊量要越小越好。<br>常見的資訊量有兩種：<ol><li>熵(Entropy)<ul><li>熵 (Entropy) 是計算 Information Gain 的一種方法。在了解 Information Gain 之前要先了解熵是如何被計算出來的。其中在下圖公式中 p 代表是的機率、q 代表否的機率。我們可以從圖中範例很清楚地知道當所有的資料都被分類一致的時候 Entropy 即為 0，當資料各有一半不同時 Entropy 即為 1。<br><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247mh1JOY7jsZ.png" alt="Entropy"></li></ul></li><li>Gini 不純度 (Gini Impurity)<ul><li>Gini 不純度是另一種亂度的衡量方式，它的數字越大代表序列中的資料越混亂。公式如下所示，其中 p 代表是的機率、q 為代表的機率。我們可以從圖中範例很清楚地知道當所有的資料都被分類一致的時候混亂程度即為 0，當資料各有一半不同時混亂程度即為 0.5。<br><img src="https://ithelp.ithome.com.tw/upload/images/20210924/20107247b3lmqP6cDf.png" alt="Gini"></li></ul></li></ol></li></ul><h1 id="Random-Forest-隨機森林"><a href="#Random-Forest-隨機森林" class="headerlink" title="Random Forest(隨機森林)"></a>Random Forest(隨機森林)</h1><p>Random Forest的基本原理是，結合多顆CART樹（CART樹為使用GINI算法的決策樹），並加入隨機分配的訓練資料，以大幅增進最終的運算結果。顧名思義就是由許多不同的決策樹所組成的一個學習器，其想法就是結合多個「弱學習器」來建構一個更強的模型：「強學習器」。這種方法又稱為整體機器學習(Ensemble learning)演算法，而這種模型比較不會有偏差或是發生高度適合(Overfit)。</p><h2 id="形成多棵樹"><a href="#形成多棵樹" class="headerlink" title="形成多棵樹"></a>形成多棵樹</h2><p>我們只有一個數據集，為了進行Ensemble Method，所以是要產生不同的數據集，如此才能產生多顆具差異性的CART樹，其作法有兩種方式：</p><ol><li><p>Bagging(Boostrap Aggregation)<br>此種作法是從原有的數據集內重新取樣產生新的數據集，且取的過程是「均勻且可重複取樣的」<br>這種做法會從原有的數據集內產生新的k個數據集，再訓練出k個分類器(CART樹)，每次取出的數據都會放回原數據集，因此彼此之間可能會有資料重複，不過每個樹還是會有不同的樣本，因此每棵樹還是不同的，最後每個樹的權重統一由投票方式決定(Majority vote)</p></li><li><p>Boosting<br>和Bagging方式類似，不過更強調「對錯誤的部分加強學習」，透過將舊分類器錯誤資料的權重提高，加重對錯誤資料的訓練，訓練出新的分類器，這樣新的分類器就會學習到錯誤資料的特性，進而提升分類結果。</p></li></ol><h2 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h2><ol><li>定義大小為n的隨機樣本（這裡指的是用bagging方法），就是從資料集中隨機選取n個資料，取完後放回。</li><li>從選取的n個資料中，訓練出決策樹。對每一個節點：</li></ol><ul><li>隨機選取d個特徵</li><li>使用特徵分割該節點（信息增益，information gain）</li></ul><ol start="3"><li>重複k次步驟1~步驟2</li><li>匯總所有決策樹的預測，以多數決的方式，來決定分類結果。</li></ol><h1 id="SVM-支援向量機"><a href="#SVM-支援向量機" class="headerlink" title="SVM(支援向量機)"></a>SVM(支援向量機)</h1><p>支持向量機 (support vector machine, SVM) 是一個基於統計學習的監督式演算法，透過找出一個超平面，使之將兩個不同的集合分開。一般的分類問題我們就是要找出在不同的資料類別中的分隔線。但在一般狀況下這個分隔線非常複雜且有很多種可能。然而 SVM 就是要在這很多種的可能當中找出最佳的解。SVM演算法的精神就是找出一條分隔線使所有在邊界上的點離得越遠越好，使模型抵抗雜訊的能力更佳。</p><h2 id="種類"><a href="#種類" class="headerlink" title="種類"></a>種類</h2><ol><li>線性分類器 (Linear Classifiers):<br> 線性可分支持向量機就是在下圖範例的二維圖形中找出一條線，目標讓這條直線與兩個類別之間的間隔寬度距離最大化。其中離兩條虛線(間隔超平面)距離最近的點，就稱為支持向量 (support vector)。<br> <img src="https://ithelp.ithome.com.tw/upload/images/20210923/20107247rJUDvApGWA.png" alt="Linear"></li><li>非線性可分支持向量機(Non-linear Classifiers):<br> 除了進行線性分類之外 SVM 還可以使用核技巧有效地進行非線性分類，將其輸入的資料投到更高維度的空間，並在高維度的空間進行高維度的分類或降維。簡單來說透過多維度的投影技巧，將原本在二維空間中不可分的點到了三維空間就可分了。但是隨著資料量增加其運算也會變多，相對的執行速度就會變慢。<br> <img src="https://ithelp.ithome.com.tw/upload/images/20210923/201072470aQeXnnzv1.png" alt="Non-Linear"><br> 兩個非線性的 Kernel：<ul><li>Polynomial 高次方轉換</li><li>Radial Basis Function 高斯轉換</li></ul></li></ol><h2 id="二元分類-v-s-多元分類"><a href="#二元分類-v-s-多元分類" class="headerlink" title="二元分類 v.s. 多元分類"></a>二元分類 v.s. 多元分類</h2><ul><li>one-vs-rest(OvR)<br>將某個類別的樣本歸為一類，其他剩餘的樣本歸為另一類</li><li>many-vs-many(MvM)<br>在任意兩類樣本之間設計一個SVM</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://ithelp.ithome.com.tw/articles/10271143">[Day 12] 決策樹 (Decision tree)</a><br><a href="https://medium.com/jameslearningnote/%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E7%AC%AC3-5%E8%AC%9B-%E6%B1%BA%E7%AD%96%E6%A8%B9-decision-tree-%E4%BB%A5%E5%8F%8A%E9%9A%A8%E6%A9%9F%E6%A3%AE%E6%9E%97-random-forest-%E4%BB%8B%E7%B4%B9-7079b0ddfbda">[資料分析&amp;機器學習] 第3.5講 : 決策樹(Decision Tree)以及隨機森林(Random Forest)介紹</a><br><a href="https://medium.com/jameslearningnote/%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E7%AC%AC3-4%E8%AC%9B-%E6%94%AF%E6%8F%B4%E5%90%91%E9%87%8F%E6%A9%9F-support-vector-machine-%E4%BB%8B%E7%B4%B9-9c6c6925856b">[資料分析&amp;機器學習] 第3.4講：支援向量機(Support Vector Machine)介紹</a><br><a href="https://ithelp.ithome.com.tw/articles/10270447">[Day 11] 核模型 - 支持向量機 (SVM)</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> classification </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustering</title>
      <link href="/larry891001/2022/04/08/ML/clustering/"/>
      <url>/larry891001/2022/04/08/ML/clustering/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="非監督式學習-Unsupervised-Learning"><a href="#非監督式學習-Unsupervised-Learning" class="headerlink" title="非監督式學習(Unsupervised Learning)"></a>非監督式學習(Unsupervised Learning)</h2><p>所有資料都沒有標註，機器透過尋找資料的特徵，自己進行分類。此種方法不用人工進行分類，對人類來說最簡單，但對電腦來說最辛苦，誤差較大。若使用非監督式學習辨識大象及長頸鹿，機器得自行判斷提供的照片裡有哪些特徵是大象、哪些特徵的是長頸鹿並同時進行分類。目的是要探索資料並找出其中的結構。</p><h2 id="K-means-Algorithm"><a href="#K-means-Algorithm" class="headerlink" title="K-means Algorithm"></a>K-means Algorithm</h2><p>K-means Clustering這個方法就是「物以類聚」的概念。男生就是男生，女生就是女生，男生會自己聚成一群，女生也會自己聚成一群。<br>但在這群男生自己不會動成一群，女生也不會動成一群，在機器學習內，我們有的就是一組不會動的身高和體重的資料。那是什麼會動，讓男生女生可以區隔開的是什麼? k-means，這邊的k是你想分成幾群，means就是每一群群心（cluster centroid），所以會動的東西就是群心。<br>如果用實際的例子說，大家到新學校上學的時候有沒有一種感覺，第一天到的時候基本上大家都不熟，一個兩個人是一群，後來慢慢會有一群人聚在一起，沒幾天就分成兩群、三群，慢慢的到上學後一個月，基本上班上的小團體都分好了，每個團體都有一個key-man，你可以把這個key-man當作是群心，基本上大家都是因為有這個key-man聚在一起的(如果變節又是另一件事情)。那這個key-man在開學到小團體分好之前，基本上有可能會一直換來換去的，甚至多出一個key-man或是少一個key-man(演算法:ISODATA)，或是這個團體的key-man會因為別人的強勢而換掉，這就是<code>會動=換掉</code>的群心。</p><h2 id="Steps-of-K-means"><a href="#Steps-of-K-means" class="headerlink" title="Steps of K-means"></a>Steps of K-means</h2><p>目的是要決定K個聚類，其滿足最小的square-error function<br><img src="https://img.onl/fOxR3N" alt="clustering1"></p><ol><li>Given n objects, initialize k cluster centers.</li><li>Assign each object to its closest cluster center.</li><li>Update the center for each cluster.</li><li>Repeat 2 and 3 until no change in each cluster center.</li></ol><h2 id="Distance-Measure-Method"><a href="#Distance-Measure-Method" class="headerlink" title="Distance Measure Method"></a>Distance Measure Method</h2><ol><li><p>Euclidean distance measure:</p><ul><li>Simplest</li><li>兩點間的直線距離</li></ul></li><li><p>Cosine distance measure:</p><ul><li> Finds the cosine of angle between two vectors (vectors drawn from origin to the points.)</li></ul></li><li><p>Manhattan distance measure: </p><ul><li>The sum of the absolute differences of the coordinates of two point</li><li>線段的距離總和</li></ul></li></ol><h2 id="The-Drawback-of-K-means"><a href="#The-Drawback-of-K-means" class="headerlink" title="The Drawback of K-means"></a>The Drawback of K-means</h2><ul><li><p>The parameter of K-means:</p><ul><li>Must decide the number of cluster in advance.<br>(分類前必須先定義好群集數量)</li><li>Different initial center will result in different cluster result.<br>(不同的initial center會導致不一樣的結果)</li></ul></li><li><p>The center of K-means can be virtual node.</p></li><li><p>Drawback:</p><ul><li>K-means cannot deal with category data.</li><li>K-means is heavily affect by noise(離群值).<ul><li><code>K-medoids</code></li></ul></li></ul></li></ul><h2 id="K-means-vs-K-medoids"><a href="#K-means-vs-K-medoids" class="headerlink" title="K-means vs. K-medoids"></a>K-means vs. K-medoids</h2><p><img src="https://img.onl/MZNrgy" alt="k-means-vs.K-medoids"></p><h2 id="Hierarchical-Clustering"><a href="#Hierarchical-Clustering" class="headerlink" title="Hierarchical Clustering"></a>Hierarchical Clustering</h2><ul><li>Hierarchical clustering (階層式分群法) is a hierarchical method which generate the clusters by iteratively(聚合) or divisive(分裂) data.</li></ul><ol><li>Agglomerative<ul><li>It is a “bottom-up” method.</li><li>Prepare basic components and iteratively combine the components to be a final solution</li><li>Steps<ol><li>Every node is a cluster</li><li>Scan all the nodes. Choose two nodes which are closest to be a cluster.</li><li>Repeat 2 and 3 until all data becomes a cluster or achieve the x cluster</li></ol></li></ul></li><li>Divisive<ul><li>It is a “top-down” method.</li><li>See the whole picture of the problem and iteratively add the detail to make the solution clear.</li><li>Regard the data as a cluster and iteratively divide the data.</li></ul></li></ol><h2 id="Distance-of-Two-Clusters"><a href="#Distance-of-Two-Clusters" class="headerlink" title="Distance of Two Clusters"></a>Distance of Two Clusters</h2><ol><li>Single-linkage agglomerative algorithm (單一連結聚合演算法)<ul><li>群間的距離定義為兩群中最近點的距離</li></ul></li><li>Complete-linkage agglomerative algorithm (完整連結聚合演算法)<ul><li>群間的距離定義為兩群中最遠點間的距離</li></ul></li><li>Average-linkage agglomerative algorithm (平均連結聚合演算法)<ul><li>群間的距離定義為兩群間各點間的距離總和平均</li></ul></li><li>Centroid method (中心聚合演算法)<ul><li>群間的距離定義為兩群中心點間的距離</li></ul></li><li>Ward’s method (沃德法)<ul><li>群間的距離定義為兩群合併後，各點到合併群中心的距離平方和</li></ul></li></ol><h2 id="Drawback"><a href="#Drawback" class="headerlink" title="Drawback:"></a>Drawback:</h2><ul><li>Hierarchical clustering needs much computation resource since the method has to scan every data in each iteration</li></ul><h2 id="DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise"><a href="#DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise" class="headerlink" title="DBSCAN(Density-Based Spatial Clustering of Applications with Noise)"></a>DBSCAN(Density-Based Spatial Clustering of Applications with Noise)</h2><ul><li>原理<br>該演算法將具有足夠密度區域作為距離中心，不斷生長該區域，演算法基於一個事實：一個聚類可以由其中的任何核心物件唯一確定。該演算法利用基於密度的聚類的概念，即要求聚類空間中的一定區域內所包含物件（點或其他空間物件）的數目不小於某一給定閾值。該方法能在具有噪聲的空間資料庫中發現任意形狀的簇，可將密度足夠大的相鄰區域連線，能有效處理異常資料，主要用於對空間資料的聚類</li><li>基本概念<ol><li>Eps鄰域：給定物件半徑Eps內的鄰域稱為該物件的Eps鄰域;</li><li>核心點（core point）：如果物件的Eps鄰域至少包含最小數目MinPts的物件，則稱該物件為核心物件;</li><li>邊界點（border point）：邊界點不是核心點，但落在某個核心點的鄰域內;</li><li>噪音點（outlier point）：既不是核心點，也不是邊界點的任何點;</li></ol></li><li>優點<ol><li>聚類速度快且能夠有效處理噪聲點和發現任意形狀的空間聚類；</li><li>與K-MEANS比較起來，不需要輸入要劃分的聚類個數；</li><li>聚類簇的形狀沒有偏倚；   </li><li>可以在需要時輸入過濾噪聲的引數。</li></ol></li><li>完整運作流程<br><img src="https://miro.medium.com/max/1350/0*o_BoNtBbwvAiNFLB.gif" alt="cluster"></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://medium.com/chung-yi/ml%E5%85%A5%E9%96%80-%E5%8D%81%E5%85%AB-k-means-f92b9f1e8871">ML入門（十八）K-Means</a></p><p><a href="https://medium.com/ai-academy-taiwan/clustering-method-4-ed927a5b4377">Clustering Method 4</a></p><p><a href="https://axk51013.medium.com/%E4%B8%8D%E8%A6%81%E5%86%8D%E7%94%A8k-means-%E8%B6%85%E5%AF%A6%E7%94%A8%E5%88%86%E7%BE%A4%E6%B3%95dbscan%E8%A9%B3%E8%A7%A3-a33fa287c0e">不要再用K-means！ 超實用分群法DBSCAN詳解</a></p><p><a href="https://www.itread01.com/content/1547194697.html">聚類方法：DBSCAN演算法研究（1）–DBSCAN原理、流程、引數設定、優缺點以及演算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Clustering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regression</title>
      <link href="/larry891001/2022/04/08/ML/regression/"/>
      <url>/larry891001/2022/04/08/ML/regression/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="迴歸分析"><a href="#迴歸分析" class="headerlink" title="迴歸分析"></a>迴歸分析</h2><ul><li>迴歸分析是預測數值的分析</li><li>機器學習會預測資料，成為機器學習基礎的就是迴歸分析</li><li>對於輸出(目標變數)與輸入(解釋變數)的關係，若是輸入一個變數則為「簡單迴歸分析」</li><li>若是輸入2個以上的變數，則為「多元迴歸分析」</li></ul><h2 id="迴歸問題"><a href="#迴歸問題" class="headerlink" title="迴歸問題"></a>迴歸問題</h2><p>在迴歸問題裡，從給予的資料來假設關係式，逐步求取最合適的係數</p><ul><li>例如：已知G1的成績，預測G3的成績</li><li>將G3視為目標(目標變數)，G1為解釋變數，來進行預測</li><li>這就是之前提到的「監督式學習」之一：在學習時的資料逐一給予正確解答，作為計算關聯性的基礎</li></ul><h2 id="簡單迴歸分析"><a href="#簡單迴歸分析" class="headerlink" title="簡單迴歸分析"></a>簡單迴歸分析</h2><ul><li>輸出與輸入之間成立線性關係(y=ax+b)，則為簡單線性迴歸分析</li><li>scikit-learn為機器學習的套件</li><li>我們可以使用scikit-learn引入linear_model進行簡單線性迴歸分析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">reg = linear_model.LinearRegression()</span><br></pre></td></tr></table></figure><h2 id="fit函式"><a href="#fit函式" class="headerlink" title="fit函式"></a>fit函式</h2><ul><li>解釋變數(X)和目標變數(Y)資料，使用線性迴歸的fit函式功能，計算預測模型</li><li>使用<code>最小平方法</code>來計算迴歸係數a與截距b</li></ul><p><img src="https://img.onl/vZogva" alt="regression"></p><h2 id="決定係數-R-2"><a href="#決定係數-R-2" class="headerlink" title="決定係數(R^2)"></a>決定係數(R^2)</h2><ul><li>從上頁的圖形，預測式似乎能很好地預測出實際值，但是否客觀無從判斷</li><li>因此我們需要「決定係數」（Coefficient of determination）</li><li>決定係數是一個解釋性係數，在迴歸分析中，其主要作用是評估迴歸模型對因變量y產生變化的解釋程度，也即判定係數R平方是評估迴歸模型好壞的指標。R平方取值範圍也為0~1，通常以百分數表示。比如迴歸模型的R平方等於0.7，那麼表示，此回歸模型對預測結果的可解釋程度為70%。</li></ul><p><img src="https://img.onl/pnNg8I" alt="regression1"></p><h2 id="多元線性迴歸"><a href="#多元線性迴歸" class="headerlink" title="多元線性迴歸"></a>多元線性迴歸</h2><ul><li>一般線性迴歸: 對於目標變數只有一個解釋變數。<br>  <code>y=ax+b</code></li><li>多元線性迴歸: 解釋變數有多個。<br>  <code>y=a1x1+a2x2+a3x3+…..+b</code></li><li>藉由多元線性迴歸，可以計算出各個解釋變數之係數(迴歸係數)的推論預測值。</li><li>迴歸係數是以讓預測值與目標變數的平方誤差最小化的方式推論</li></ul><h2 id="Example-建置預測汽車價格的模型"><a href="#Example-建置預測汽車價格的模型" class="headerlink" title="Example: 建置預測汽車價格的模型"></a>Example: 建置預測汽車價格的模型</h2><ul><li>汽車價格和汽車的一些屬性(汽車的大小等)有相關聯</li><li>目標：利用多元線性回歸，建構出能從這些屬性預測汽車價格的模型</li></ul><ol><li>引入資料處理library<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先導入資料處理會用到的模組</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.random <span class="keyword">as</span> random</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可視化模組</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 機器學習模組</span></span><br><span class="line"><span class="comment">#請輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="comment"># 表示到小數第三位</span></span><br><span class="line">%precision <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>讀取汽車售價資料<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, zipfile</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得汽車data</span></span><br><span class="line">url = <span class="string">&#x27;http://archive.ics.uci.edu/ml/machine-learning-databases/autos/imports-85.data&#x27;</span></span><br><span class="line">res = requests.get(url).content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將取得的資料作為DataFrame物件讀取</span></span><br><span class="line">auto = pd.read_csv(io.StringIO(res.decode(<span class="string">&#x27;utf-8&#x27;</span>)), header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在資料的行裡設定標籤</span></span><br><span class="line">auto.columns =[<span class="string">&#x27;symboling&#x27;</span>,<span class="string">&#x27;normalized-losses&#x27;</span>,<span class="string">&#x27;make&#x27;</span>,<span class="string">&#x27;fuel-type&#x27;</span> ,<span class="string">&#x27;aspiration&#x27;</span>,<span class="string">&#x27;num-of-doors&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;body-style&#x27;</span>,<span class="string">&#x27;drive-wheels&#x27;</span>,<span class="string">&#x27;engine-location&#x27;</span>,<span class="string">&#x27;wheel-base&#x27;</span>,<span class="string">&#x27;length&#x27;</span>,<span class="string">&#x27;width&#x27;</span>,<span class="string">&#x27;height&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;curb-weight&#x27;</span>,<span class="string">&#x27;engine-type&#x27;</span>,<span class="string">&#x27;num-of-cylinders&#x27;</span>,<span class="string">&#x27;engine-size&#x27;</span>,<span class="string">&#x27;fuel-system&#x27;</span>,<span class="string">&#x27;bore&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;stroke&#x27;</span>,<span class="string">&#x27;compression-ratio&#x27;</span>,<span class="string">&#x27;horsepower&#x27;</span>,<span class="string">&#x27;peak-rpm&#x27;</span>,<span class="string">&#x27;city-mpg&#x27;</span>,<span class="string">&#x27;highway-mpg&#x27;</span>,<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;汽車資料的形式:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(auto.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment">#顯示最開始的5列</span></span><br><span class="line"><span class="comment">#請出入程式碼</span></span><br><span class="line">auto.head()</span><br></pre></td></tr></table></figure><div class="note simple"><p>汽車資料的形式: (205, 26) //代表為205列26行的資料<br><img src="https://img.onl/PmXl3Y" alt="regression3"></p></div><ul><li>在這個資料裡，汽車的價格訂於「price」中。</li><li>所以我們的模型就是要從price以外的欄位值來預測price這個欄位。</li><li>因為從全部的欄位來解釋price會太複雜，以下的範例使用「width、engine-size」這兩個解釋變數來預測模型。</li></ul></li><li>資料前處理<ul><li>資料有時會包含不適當的東西，例如: ?, NAN之類的，所以要進行確認，去除不適當的資料。</li><li>剛剛使用head()之後發現有「?」的資料，可以怎麼處理？</li><li>如何處理遺漏值？<pre><code>  1. 去除那一列  2. 補0  3. 補前一列的值</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 計算各個行(欄位)裡有多少個“？”</span></span><br><span class="line">auto = auto[[<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;width&#x27;</span>,<span class="string">&#x27;engine-size&#x27;</span>]]</span><br><span class="line">auto.isin([<span class="string">&#x27;?&#x27;</span>]).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將?取代為NaN，刪除有NaN的列</span></span><br><span class="line">auto = auto.replace(<span class="string">&#x27;?&#x27;</span>,np.nan).dropna()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;汽車資料的形式:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(auto.shape))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;資料型別的確認（型別轉換前）\n&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(auto.dtypes))</span><br><span class="line"></span><br><span class="line"><span class="comment">#資料型別轉換</span></span><br><span class="line">auto = auto.assign(price = pd.to_numeric(auto.price))</span><br><span class="line"><span class="comment">#auto = auto.assign(horsepower = pd.to_numeric(auto.horsepower))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;資料型別的確認（型別轉換後）\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(auto.dtypes))</span><br></pre></td></tr></table></figure></li></ul></li><li>確認相關性<ul><li>經過上述已經將目標變數、解釋變數的所有列加工為沒有遺漏且為數執行別的資料形式</li><li>接下來要確認各個變數的相關性</li><li>使用corr<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#觀察相關性</span></span><br><span class="line">auto.corr()</span><br></pre></td></tr></table></figure><h3 id="多元共線性問題"><a href="#多元共線性問題" class="headerlink" title="多元共線性問題"></a>多元共線性問題</h3></li><li>多元共線性是由於變數間的高相關性，迴歸係數的變異數變大，失去了係數的顯著性。</li><li>這樣的現象應該避免，所以建構多元線性迴歸的模型時，通常只挑出能代表高相關性變數群的變數來用於模型。</li></ul></li><li>開始訓練<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 為了資料分割(訓練資料與測試資料)的匯入</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 為了多元線性迴歸模型建構的導入</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"> <span class="comment"># 指定目標變數為price、其他為解釋變數</span></span><br><span class="line">X = auto.drop(<span class="string">&#x27;price&#x27;</span>,axis=<span class="number">1</span>)</span><br><span class="line">y = auto[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line"><span class="comment"># 分為訓練資料與測試資料</span></span><br><span class="line"><span class="comment"># 以何種比例來分取決於test_size，這裡將test_size比例設為0.5，資料會分一半</span></span><br><span class="line"><span class="comment"># random_state用以控制亂數的生成</span></span><br><span class="line"><span class="comment"># 將random_state固定(設為0)， 則是無論執行幾次都能一樣地分離資料</span></span><br><span class="line"><span class="comment"># 如果不指定為任意的值，每次執行時某列不一定會被歸類於訓練資料或是測試資料，無法得到相同的結果</span></span><br><span class="line"><span class="comment"># 因此模型效能的驗證時，會將random_state固定</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.5</span>,random_state = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 多元線性迴歸的初始化學習</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_train,y_train)</span><br><span class="line"><span class="comment"># 顯示決定係數</span></span><br><span class="line"><span class="comment"># 學習好之後，可將決定係數與相關係數以截距確認</span></span><br><span class="line"><span class="comment"># 決定係數是用來表示對於目標變數來說，預測值與實際的目標變數之值有多接近</span></span><br><span class="line"><span class="comment"># 決定係數可用score方法取得</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;決定係數(train):&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(model.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;決定係數(test):&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(model.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示迴歸係數與截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n迴歸係數\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pd.Series(model.coef_, index=X.columns)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;截距: &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(model.intercept_))</span><br></pre></td></tr></table></figure><div class="note modern"><p>決定係數(train):0.783<br>決定係數(test):0.778</p><p>迴歸係數<br>width          1261.735518<br>engine-size     109.526787<br>dtype: float64<br>截距: -84060.643</p></div></li></ol><h2 id="Overfitting-過度學習"><a href="#Overfitting-過度學習" class="headerlink" title="Overfitting(過度學習)"></a>Overfitting(過度學習)</h2><ul><li>機器學習的目的是獲得高度泛用性，也就是建構出來的模型，對於未知的資料也能正確地預測。</li><li>儘管追求對於訓練資料的吻合度看似能得到較好的模型，實際上並非如此，經常出現對於訓練資料準確度很高，但對於測試資料準確度卻降低的情形。</li><li>建構模型時需要特別注意是否有此現象，可以觀察train跟test的分數，若差距太大就可能為過度學習或是過擬合(Overfitting)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas</title>
      <link href="/larry891001/2022/03/27/ML/pandas/"/>
      <url>/larry891001/2022/03/27/ML/pandas/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="Pandas的基礎"><a href="#Pandas的基礎" class="headerlink" title="Pandas的基礎"></a>Pandas的基礎</h2><ul><li>Pandas是在用Python建立模型之前進行資料預處理的便利函式庫。</li><li>Pandas可對各式各樣的資料進行有彈性地加工處理，執行表格試算與資料抽出、搜尋等操作。</li></ul><h2 id="Pandas函式庫的匯入"><a href="#Pandas函式庫的匯入" class="headerlink" title="Pandas函式庫的匯入"></a>Pandas函式庫的匯入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure><ul><li>匯入Pandas函式庫</li><li>匯入處理1維陣列的Series函式庫</li><li>匯入處理2維陣列的DataFrame函式庫</li></ul><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><ul><li>Series是類似1維陣列的物件</li><li>Pandas的基礎為Numpy的array</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sample_pandas_data = pd.Series([<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>])</span><br><span class="line"><span class="comment">#印出資料值</span></span><br><span class="line"><span class="built_in">print</span>(sample_pandas_data.values)</span><br><span class="line"><span class="comment">#印出索引值</span></span><br><span class="line"><span class="built_in">print</span>(sample_pandas_data.index)</span><br><span class="line"><span class="comment">#輸入自訂的文字index</span></span><br><span class="line">sample_pandas_index_data = pd.Series(</span><br><span class="line">    [<span class="number">0</span>, <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>],</span><br><span class="line">    index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(sample_pandas_index_data)</span><br></pre></td></tr></table></figure><div class="note flat"><p>資料值:  [ 0 10 20 30 40 50 60 70 80 90]<br>索引值:  RangeIndex(start=0, stop=10, step=1)</p><p>a     0<br>b    10<br>c    20<br>d    30<br>e    40<br>f    50<br>g    60<br>h    70<br>i    80<br>j    90<br>dtype: int64</p></div><ul><li>取得資料值： Series.values</li><li>取得index值： Series.index</li><li>左列為index索引值，右列為資料(元素)，索引值可以自訂義</li></ul><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><ul><li>DataFrame物件是2維陣列。</li><li>對於各行可以設定不同的dtype(資料型別)。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">attri_data1 = &#123;<span class="string">&#x27;ID&#x27;</span>:[<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;104&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;City&#x27;</span>:[<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Hsinchu&#x27;</span>,<span class="string">&#x27;Tainan&#x27;</span>,<span class="string">&#x27;Kaohsiung&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;Birth_year&#x27;</span>:[<span class="number">1990</span>,<span class="number">1989</span>,<span class="number">1992</span>,<span class="number">1997</span>,<span class="number">1982</span>],</span><br><span class="line">               <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Sally&#x27;</span>,<span class="string">&#x27;Hanks&#x27;</span>,<span class="string">&#x27;Hannah&#x27;</span>,<span class="string">&#x27;Kitty&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">attri_data_frame1 = DataFrame(attri_data1)</span><br><span class="line"><span class="comment">#一樣可以自訂自己想要的index</span></span><br><span class="line">attri_data_frame_index1 = DataFrame(attri_data1,index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame_index1)</span><br><span class="line"><span class="comment">#轉置</span></span><br><span class="line">attri_data_frame1.T</span><br></pre></td></tr></table></figure><ul><li>一般</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td></tr><tr><td align="right">3</td><td align="right">103</td><td align="right">Tainan</td><td align="right">1997</td><td align="right">Kitty</td></tr><tr><td align="right">4</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">1982</td><td align="right">Steve</td></tr></tbody></table><ul><li>轉置後</li></ul><table><thead><tr><th align="right">Index</th><th align="right">0</th><th align="right">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td align="right">ID</td><td align="right">100</td><td align="right">101</td><td align="right">102</td><td align="right">103</td><td align="right">104</td></tr><tr><td align="right">City</td><td align="right">Taipei</td><td align="right">Taipei</td><td align="right">Hsinchu</td><td align="right">Tainan</td><td align="right">Kaohsiung</td></tr><tr><td align="right">Birth_year</td><td align="right">1990</td><td align="right">1989</td><td align="right">1992</td><td align="right">1997</td><td align="right">1982</td></tr><tr><td align="right">Name</td><td align="right">Sally</td><td align="right">Hanks</td><td align="right">Hannah</td><td align="right">Kitty</td><td align="right">Steve</td></tr></tbody></table><h3 id="只取出特定行-amp-資料過濾"><a href="#只取出特定行-amp-資料過濾" class="headerlink" title="只取出特定行&amp;資料過濾"></a>只取出特定行&amp;資料過濾</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取得Birth_year行</span></span><br><span class="line">attri_data_frame1.Birth_year</span><br><span class="line"><span class="comment">#取得ID與Birth_year行</span></span><br><span class="line">attri_data_frame1[[<span class="string">&#x27;ID&#x27;</span>,<span class="string">&#x27;Birth_year&#x27;</span>]]</span><br><span class="line"><span class="comment">#對於DataFrame物件，也能只取出滿足特定條件的資料，或是結合多筆資料 =&gt; 如同過濾器(filter)。</span></span><br><span class="line"><span class="comment"># attri_data_frame1中找出City為Taipei的資料</span></span><br><span class="line">attri_data_frame1[attri_data_frame1[<span class="string">&#x27;City&#x27;</span>]==<span class="string">&#x27;Taipei&#x27;</span>]</span><br><span class="line"><span class="comment"># 若是將”City行”的元素逐一和”Taipei”進行比較，取出單獨顯示，就可以看出是True還是False</span></span><br><span class="line">attri_data_frame1[<span class="string">&#x27;City&#x27;</span>] == <span class="string">&#x27;Taipei&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="DataFrame中行列的刪除"><a href="#DataFrame中行列的刪除" class="headerlink" title="DataFrame中行列的刪除"></a>DataFrame中行列的刪除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#去掉Birth_year這一行</span></span><br><span class="line">attri_data_frame1.drop([<span class="string">&#x27;Birth_year&#x27;</span>], axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">attri_data1 = &#123;<span class="string">&#x27;ID&#x27;</span>:[<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;104&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;City&#x27;</span>:[<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Hsinchu&#x27;</span>,<span class="string">&#x27;Tainan&#x27;</span>,<span class="string">&#x27;Kaohsiung&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;Birth_year&#x27;</span>:[<span class="number">1990</span>,<span class="number">1989</span>,<span class="number">1992</span>,<span class="number">1997</span>,<span class="number">1982</span>],</span><br><span class="line">               <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Sally&#x27;</span>,<span class="string">&#x27;Hanks&#x27;</span>,<span class="string">&#x27;Hannah&#x27;</span>,<span class="string">&#x27;Kitty&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">attri_data_frame1 = DataFrame(attri_data1)</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用assign，使得attri_data_frame1的資料中真正拿掉Birth_year行</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line">attri_data_frame1 = attri_data_frame1.drop([<span class="string">&#x27;Birth_year&#x27;</span>], axis = <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame1)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td></tr><tr><td align="right">3</td><td align="right">103</td><td align="right">Tainan</td><td align="right">1997</td><td align="right">Kitty</td></tr><tr><td align="right">4</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">1982</td><td align="right">Steve</td></tr></tbody></table><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">Taipei</td><td align="right">Sally</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">Taipei</td><td align="right">Hanks</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">Hannah</td></tr><tr><td align="right">3</td><td align="right">103</td><td align="right">Tainan</td><td align="right">Kitty</td></tr><tr><td align="right">4</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">Steve</td></tr></tbody></table><h3 id="DataFrame資料的結合"><a href="#DataFrame資料的結合" class="headerlink" title="DataFrame資料的結合"></a>DataFrame資料的結合</h3><ul><li>DataFrame物件之間可以結合。</li><li>資料分析裡有各式各樣的資料，經常會將他們結合進行分析。</li><li>使用merge進行結合，結合時會依據兩邊共同的分類進行結合。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#準備資料</span></span><br><span class="line">attri_data1 = &#123;<span class="string">&#x27;ID&#x27;</span>:[<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;104&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;City&#x27;</span>:[<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Hsinchu&#x27;</span>,<span class="string">&#x27;Tainan&#x27;</span>,<span class="string">&#x27;Kaohsiung&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;Birth_year&#x27;</span>:[<span class="number">1990</span>,<span class="number">1989</span>,<span class="number">1992</span>,<span class="number">1997</span>,<span class="number">1982</span>],</span><br><span class="line">               <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Sally&#x27;</span>,<span class="string">&#x27;Hanks&#x27;</span>,<span class="string">&#x27;Hannah&#x27;</span>,<span class="string">&#x27;Kitty&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>]&#125;</span><br><span class="line">attri_data_frame1 = DataFrame(attri_data1)</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">attri_data2 = &#123;<span class="string">&#x27;ID&#x27;</span>:[<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;105&#x27;</span>,<span class="string">&#x27;107&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;Math&#x27;</span>:[<span class="number">50</span>,<span class="number">43</span>,<span class="number">33</span>,<span class="number">76</span>,<span class="number">98</span>],</span><br><span class="line">               <span class="string">&#x27;English&#x27;</span>:[<span class="number">90</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>],</span><br><span class="line">               <span class="string">&#x27;Sex&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;M&#x27;</span>]&#125;</span><br><span class="line">attri_data_frame2 = DataFrame(attri_data2)</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame2)</span><br><span class="line"><span class="comment">#合併資料</span></span><br><span class="line">pd.merge(attri_data_frame1,attri_data_frame2)</span><br></pre></td></tr></table></figure><ul><li>attri_data_frame1</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td></tr><tr><td align="right">3</td><td align="right">103</td><td align="right">Tainan</td><td align="right">1997</td><td align="right">Kitty</td></tr><tr><td align="right">4</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">1982</td><td align="right">Steve</td></tr></tbody></table><ul><li>attri_data_frame2</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">Math</th><th align="right">English</th><th align="right">Sex</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">50</td><td align="right">90</td><td align="right">M</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">43</td><td align="right">30</td><td align="right">F</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">33</td><td align="right">20</td><td align="right">F</td></tr><tr><td align="right">3</td><td align="right">105</td><td align="right">76</td><td align="right">50</td><td align="right">M</td></tr><tr><td align="right">4</td><td align="right">107</td><td align="right">98</td><td align="right">30</td><td align="right">M</td></tr></tbody></table><ul><li>Merge後</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th><th align="right">Math</th><th align="right">English</th><th align="right">Sex</th></tr></thead><tbody><tr><td align="right">0</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td><td align="right">50</td><td align="right">90</td><td align="right">M</td></tr><tr><td align="right">1</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td><td align="right">43</td><td align="right">30</td><td align="right">F</td></tr><tr><td align="right">2</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td><td align="right">33</td><td align="right">20</td><td align="right">F</td></tr></tbody></table><ul><li>將 attri_data_frame1 與 attri_data_frame2 結合</li><li>此兩個DataFrame的共同欄位是ID</li><li>選擇ID一樣的進行結合</li></ul><h3 id="統計"><a href="#統計" class="headerlink" title="統計"></a>統計</h3><ul><li>DataFrame也可以對資料進行統計。</li><li>使用groupby便能以某個特定的行為為基準進行統計。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#將「Sex」的行設為基準來計算出數學成績的平均分數</span></span><br><span class="line"><span class="built_in">print</span>(attri_data_frame2.groupby(<span class="string">&#x27;Sex&#x27;</span>)[<span class="string">&#x27;Math&#x27;</span>].mean())</span><br><span class="line"><span class="comment">#將「Sex」的行設為基準來計算出英文成績的最大值與最小值。</span></span><br><span class="line"><span class="built_in">print</span>(attri_data_frame2.groupby(<span class="string">&#x27;Sex&#x27;</span>)[<span class="string">&#x27;English&#x27;</span>].<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(attri_data_frame2.groupby(<span class="string">&#x27;Sex&#x27;</span>)[<span class="string">&#x27;English&#x27;</span>].<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Sex</th><th align="left"></th></tr></thead><tbody><tr><td align="left">F</td><td align="left">38.000000</td></tr><tr><td align="left">M</td><td align="left">74.666667</td></tr><tr><td align="left">Name: Math</td><td align="left">dtype: float64</td></tr></tbody></table><table><thead><tr><th align="left">Sex</th><th align="left"></th></tr></thead><tbody><tr><td align="left">F</td><td align="left">30</td></tr><tr><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">Name: English</td><td align="left">dtype: int64</td></tr></tbody></table><table><thead><tr><th align="left">Sex</th><th align="left"></th></tr></thead><tbody><tr><td align="left">F</td><td align="left">20</td></tr><tr><td align="left">M</td><td align="left">30</td></tr><tr><td align="left">Name: English</td><td align="left">dtype: int64</td></tr></tbody></table><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#準備資料</span></span><br><span class="line">attri_data2 = &#123;<span class="string">&#x27;ID&#x27;</span>:[<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;101&#x27;</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;103&#x27;</span>,<span class="string">&#x27;104&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;City&#x27;</span>:[<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Taipei&#x27;</span>,<span class="string">&#x27;Hsinchu&#x27;</span>,<span class="string">&#x27;Tainan&#x27;</span>,<span class="string">&#x27;Kaohsiung&#x27;</span>],</span><br><span class="line">               <span class="string">&#x27;Birth_year&#x27;</span>:[<span class="number">1990</span>,<span class="number">1989</span>,<span class="number">1992</span>,<span class="number">1997</span>,<span class="number">1982</span>],</span><br><span class="line">               <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Sally&#x27;</span>,<span class="string">&#x27;Hanks&#x27;</span>,<span class="string">&#x27;Hannah&#x27;</span>,<span class="string">&#x27;Kitty&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>]&#125;</span><br><span class="line">attri_data_frame_index2 = DataFrame(attri_data2,index=[<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">attri_data_frame_index2</span><br><span class="line"></span><br><span class="line"><span class="comment">#sort by index</span></span><br><span class="line">attri_data_frame_index2.sort_index()</span><br><span class="line"></span><br><span class="line"><span class="comment">#sort by values</span></span><br><span class="line">attri_data_frame_index2.Birth_year.sort_values()</span><br></pre></td></tr></table></figure><ul><li><p>原始資料</p><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">e</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td></tr><tr><td align="right">b</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td></tr><tr><td align="right">a</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td></tr><tr><td align="right">d</td><td align="right">103</td><td align="right">Tainan</td><td align="right">1997</td><td align="right">Kitty</td></tr><tr><td align="right">c</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">1982</td><td align="right">Steve</td></tr></tbody></table></li><li><p>針對索引值排序</p><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">a</td><td align="right">102</td><td align="right">Hsinchu</td><td align="right">1992</td><td align="right">Hannah</td></tr><tr><td align="right">b</td><td align="right">101</td><td align="right">Taipei</td><td align="right">1989</td><td align="right">Hanks</td></tr><tr><td align="right">c</td><td align="right">104</td><td align="right">Kaohsiung</td><td align="right">1982</td><td align="right">Steve</td></tr><tr><td align="right">d</td><td align="right">103</td><td align="right">Tainan</td><td align="right">1997</td><td align="right">Kitty</td></tr><tr><td align="right">e</td><td align="right">100</td><td align="right">Taipei</td><td align="right">1990</td><td align="right">Sally</td></tr></tbody></table></li><li><p>針對某特定值排序(以Birth_year)</p><table><thead><tr><th align="left">Index</th><th align="left">Birth_year</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">1982</td></tr><tr><td align="left">b</td><td align="left">1989</td></tr><tr><td align="left">e</td><td align="left">1990</td></tr><tr><td align="left">a</td><td align="left">1992</td></tr><tr><td align="left">d</td><td align="left">1997</td></tr><tr><td align="left">Name: Birth_year</td><td align="left">dtype: int64</td></tr></tbody></table></li></ul><h3 id="nan-null-的判斷"><a href="#nan-null-的判斷" class="headerlink" title="nan(null)的判斷"></a>nan(null)的判斷</h3><ul><li>進行資料分析時，會有資料遺漏、不存在該筆資料的情況。</li><li>若是直接進行平均值計算，會無法獲得正確的數值。</li><li>此筆資料必須被排除。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#步驟1</span></span><br><span class="line"><span class="comment">#確認是否存在該值</span></span><br><span class="line">attri_data_frame_index2.isin([<span class="string">&#x27;Taipei&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#步驟2</span></span><br><span class="line"><span class="comment"># 處理遺漏值</span></span><br><span class="line"><span class="comment"># 將Name設成nan</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">attri_data_frame_index2[<span class="string">&#x27;Name&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment">#判斷是否為nan</span></span><br><span class="line">attri_data_frame_index2.isnull()</span><br><span class="line"></span><br><span class="line"><span class="comment">#步驟3</span></span><br><span class="line"><span class="comment">#計算nan的總數</span></span><br><span class="line">attri_data_frame_index2.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><ul><li>步驟1</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">e</td><td align="right">False</td><td align="right">True</td><td align="right">False</td><td align="right">False</td></tr><tr><td align="right">b</td><td align="right">False</td><td align="right">True</td><td align="right">False</td><td align="right">False</td></tr><tr><td align="right">a</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">False</td></tr><tr><td align="right">d</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">False</td></tr><tr><td align="right">c</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">False</td></tr></tbody></table><ul><li>步驟2</li></ul><table><thead><tr><th align="right">Index</th><th align="right">ID</th><th align="right">City</th><th align="right">Birth_year</th><th align="right">Name</th></tr></thead><tbody><tr><td align="right">e</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">True</td></tr><tr><td align="right">b</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">True</td></tr><tr><td align="right">a</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">True</td></tr><tr><td align="right">d</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">True</td></tr><tr><td align="right">c</td><td align="right">False</td><td align="right">False</td><td align="right">False</td><td align="right">True</td></tr></tbody></table><ul><li>步驟3<table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">0</td></tr><tr><td align="left">City</td><td align="left">0</td></tr><tr><td align="left">Birth_year</td><td align="left">0</td></tr><tr><td align="left">Name</td><td align="left">5</td></tr><tr><td align="left">dtype:int64</td><td align="left"></td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Preprocessing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Data preprocessing </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy</title>
      <link href="/larry891001/2022/03/25/ML/numpy/"/>
      <url>/larry891001/2022/03/25/ML/numpy/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="Numpy的基礎"><a href="#Numpy的基礎" class="headerlink" title="Numpy的基礎"></a>Numpy的基礎</h2><ul><li>Numpy是在科學計算裡面最常用的基本函示庫之一。</li><li>除了具有能處理多維陣列等優秀的功能外，以C語言而非Python撰寫而成的模組，處理速度快</li></ul><h2 id="陣列操作"><a href="#陣列操作" class="headerlink" title="陣列操作"></a>陣列操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">data = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])  </span><br></pre></td></tr></table></figure><div class="note flat"><p>array([ 1, 2, 3, 4, 5, 6, 7, 8, 9])</p></div><h2 id="資料型別"><a href="#資料型別" class="headerlink" title="資料型別"></a>資料型別</h2><ul><li>使用Numpy處理資料時，為了能進行高速運算，並確保計算時值的精度，有著資料的「型別」(type)。</li><li>資料型別是指「整數」與「浮點數」等值的種類。<table><thead><tr><th align="left">資料型別</th><th align="left">概述</th></tr></thead><tbody><tr><td align="left">(u)int8</td><td align="left">(不)具有正負號的8位元整數</td></tr><tr><td align="left">(u)int16</td><td align="left">(不)具有正負號的16位元整數</td></tr><tr><td align="left">(u)int32</td><td align="left">(不)具有正負號的32位元整數</td></tr><tr><td align="left">(u)int64</td><td align="left">(不)具有正負號的64位元整數</td></tr><tr><td align="left">float16</td><td align="left">16位元的浮點數</td></tr><tr><td align="left">float32</td><td align="left">32位元的浮點數</td></tr><tr><td align="left">float64</td><td align="left">64位元的浮點數</td></tr><tr><td align="left">bool</td><td align="left">表現True or False</td></tr></tbody></table></li><li>若是要查詢資料型別，可以在變數的後方指定「.dtype」</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">data = np.array([<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line">data.dtype    </span><br></pre></td></tr></table></figure><div class="note flat"><p>dtype(‘int64’)</p></div><h2 id="資料型別-1"><a href="#資料型別-1" class="headerlink" title="資料型別"></a>資料型別</h2><ul><li>維度: <code>ndim</code></li><li>元素數量: <code>size</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">data = np.array([<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;維度&#x27;</span>,data.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;元素數量&#x27;</span>,data.size)   </span><br></pre></td></tr></table></figure><div class="note flat"><p>維度 1<br>元素數量 10</p></div><h2 id="對所有元素進行運算"><a href="#對所有元素進行運算" class="headerlink" title="對所有元素進行運算"></a>對所有元素進行運算</h2><ul><li>Python中要對陣列的元素進行計算必須用「for迴圈」</li><li>Numpy可以直接對陣列進行運算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>])</span><br><span class="line">data2 = np.array([<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data*2&#x27;</span> , data*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;乘法運算：&#x27;</span>,data1*data2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;連乘：&#x27;</span>,data**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;除法：&#x27;</span>,data1/data2)</span><br></pre></td></tr></table></figure><div class="note flat"><p>data*2 [18  4  6  8 20 12 14 16  2 10]<br>乘法運算： [10 18 24 28 30 30 28 24 18  9]<br>連乘： [ 81   4   9  16 100  36  49  64   1  25]<br>除法： [0.1        0.22222222 0.375      0.57142857 0.83333333 1.2<br> 1.75       2.66666667 4.5        9.        ] </p></div><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>使用sort，預設是小到大</li><li>大到小，可用data[::-1].sort()的方式，使用切割進行操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#array值排序</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data.sort()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data[::-<span class="number">1</span>].sort()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><div class="note flat"><p>[ 1  2  3  4  5  6  7  8  9 10]<br>[ 1  2  3  4  5  6  7  8  9 10]<br>[10  9  8  7  6  5  4  3  2  1] </p></div><h2 id="最小、最大、總和、累積的計算"><a href="#最小、最大、總和、累積的計算" class="headerlink" title="最小、最大、總和、累積的計算"></a>最小、最大、總和、累積的計算</h2><ul><li>Numpy的array資料可以藉由呼叫</li><li>min:最小值</li><li>max:最大值</li><li>sum:總和</li><li>cumsum:累積和(從頭開始依序相加)運算<ul><li>第0個元素維持原樣</li><li>第1個元素=第0個元素＋第1個元素</li><li>第2個元素=第0個元素＋第1個元素＋第2個元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#array最小值、最大值、總和、累積和、累積比例</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最小值&#x27;</span>, data.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最大值&#x27;</span>, data.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;總和&#x27;</span>, data.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;累積和&#x27;</span>, data.cumsum())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;累積比例&#x27;</span>, data.cumsum()/data.<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><div class="note flat"><p>最小值 1<br>最大值 10<br>總和 55<br>累積和 [ 9 11 14 18 28 34 41 49 50 55]<br>累積比例 [0.16363636 0.2        0.25454545 0.32727273 0.50909091 0.61818182<br> 0.74545455 0.89090909 0.90909091 1.        ]</p></div><h2 id="亂數"><a href="#亂數" class="headerlink" title="亂數"></a>亂數</h2><ul><li>進行資料分析時，會使用亂數將資料隨機的分離，或是<br>加上隨機值來讓資料分佈不一致</li><li>Python也有亂數功能，但資料分析領域通常使用Numpy<br>的亂數功能</li><li>亂數是根據數學式來產生隨機值</li><li>隨機值的初始值稱為「種子」<ul><li>雖然不一定要指定種子，但是指定相同的種子，可以保證每次<br>執行都能取得相同序列的亂數</li></ul></li></ul><table><thead><tr><th align="left">功能</th><th align="left">意義</th></tr></thead><tbody><tr><td align="left">rand</td><td align="left">均勻分布，0.0以上，小於1.0</td></tr><tr><td align="left">random_sample</td><td align="left">均勻分布，0.0以上，小於1.0(和rand的引數指定方法不同)</td></tr><tr><td align="left">randint</td><td align="left">均勻分布。任意範圍的整數</td></tr><tr><td align="left">randn</td><td align="left">常態分布。平均為0、標準差為1的亂數</td></tr><tr><td align="left">normal</td><td align="left">常態分布。任意平均、標準差的亂數</td></tr><tr><td align="left">bionomial</td><td align="left">二項分布的亂數</td></tr><tr><td align="left">beta</td><td align="left">betta分布的亂數</td></tr><tr><td align="left">gemma</td><td align="left">gamma分布的亂數</td></tr><tr><td align="left">chisquare</td><td align="left">卡方分布的亂</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#產生亂數</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy.random <span class="keyword">as</span> random</span><br><span class="line">random.seed(<span class="number">0</span>)</span><br><span class="line">rnd_data = random.randn(<span class="number">10</span>)</span><br><span class="line"><span class="comment">#顯示到小數點後第三位</span></span><br><span class="line">%precision <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有10個亂數的陣列&#x27;</span>, rnd_data)</span><br></pre></td></tr></table></figure><div class="note flat"><p>含有10個亂數的陣列 [ 1.764  0.4    0.979  2.241  1.868 -0.977  0.95  -0.151 -0.103  0.411]</p></div><h2 id="資料隨機抽出"><a href="#資料隨機抽出" class="headerlink" title="資料隨機抽出"></a>資料隨機抽出</h2><ul><li>random.choice</li><li>可指定2個引數，1個參數<ul><li>第1個引數：操作對象的陣列</li><li>第2個引數：取出的個數</li><li>參數：為replace，<br>  • 若replace=True或是省略不指定，允許重複地取出，稱為「 放回抽樣」<br>  • 若replace=False，不允許資料的重複地，稱為「不放回抽樣」</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = np.array([<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 隨機取出</span></span><br><span class="line"><span class="comment"># 取出10個(允許重複，放回抽樣)</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="built_in">print</span>(random.choice(data,<span class="number">10</span>))</span><br><span class="line"><span class="comment">#  取出10個(不允許重複，不放回抽樣)</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="built_in">print</span>(random.choice(data,<span class="number">10</span>,replace= <span class="literal">False</span>))</span><br></pre></td></tr></table></figure><div class="note flat"><p>[10  6  6  7  1 10  2 10  5  1]<br>[ 6  9 10  3  4  7  1  8  5  2]</p></div><h2 id="矩陣"><a href="#矩陣" class="headerlink" title="矩陣"></a>矩陣</h2><ul><li>使用Numpy也能進行矩陣運算</li><li>arange函式具有產生指定連續整數的功能<br>  – arange(9)可產生0~8的整數</li><li>從矩陣中取出列或行，可用[列範圍, 行範圍]來取出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#產生矩陣</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array1 = np.arange(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line">array2 = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="comment">#第一列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一列&#x27;</span>, array2[<span class="number">0</span>,:])</span><br><span class="line"><span class="comment">#第一行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一行&#x27;</span>, array2[:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><div class="note flat"><p>[0 1 2 3 4 5 6 7 8]<br>[[0 1 2]<br> [3 4 5]<br> [6 7 8]]<br>第一列 [0 1 2]<br>第一行 [0 3 6]</p></div><ul><li>矩陣乘法要用「dot函式」</li><li>若是用「*」，則是將各自的元素進行乘法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#矩陣運算</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array1 = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">array2 = np.arange(<span class="number">9</span>,<span class="number">18</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array1&#x27;</span>,array1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array2&#x27;</span>,array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;矩陣乘法: &#x27;</span>, np.dot(array1,array2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;元素之積: &#x27;</span>, array1*array2)</span><br></pre></td></tr></table></figure><div class="note flat"><p>array1<br>[[0 1 2]<br> [3 4 5]<br> [6 7 8]]<br>array2<br>[[ 9 10 11]<br> [12 13 14]<br> [15 16 17]]<br>矩陣乘法:<br>[[ 42  45  48]<br> [150 162 174]<br> [258 279 300]]<br>元素之積:<br>[[  0  10  22]<br> [ 36  52  70]<br> [ 90 112 136]]</p></div><ul><li>在資料分析裡，有時需要製作元素為0或1的矩陣<br>  – 如：[0,0,0,0…..]</li><li>若是逐一寫出相當辛苦，因此提供了專用的語法</li><li>np.zeros: 產生所有元素為0的矩陣</li><li>np.ones: 產生所有元素為1的矩陣</li><li>dtype:可用來指定資料型別</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#製作元素為0或1的矩陣</span></span><br><span class="line"><span class="comment">#輸入程式碼</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.zeros((<span class="number">2</span>,<span class="number">3</span>),dtype = np.int64))</span><br><span class="line"><span class="built_in">print</span>(np.ones((<span class="number">2</span>,<span class="number">3</span>),dtype = np.float64))</span><br></pre></td></tr></table></figure><div class="note flat"><p>[[0 0 0]<br> [0 0 0]]<br>[[1. 1. 1.]<br> [1. 1. 1.]]</p></div>]]></content>
      
      
      <categories>
          
          <category> Data Preprocessing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Data preprocessing </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料前處理</title>
      <link href="/larry891001/2022/03/25/ML/datapreprocessing/"/>
      <url>/larry891001/2022/03/25/ML/datapreprocessing/</url>
      
        <content type="html"><![CDATA[<div class="note danger simple"><p>此為上課筆記</p></div><h2 id="資料前處理的重要性"><a href="#資料前處理的重要性" class="headerlink" title="資料前處理的重要性"></a>資料前處理的重要性</h2><p>資料前處理對於ML來說非常重要，就像是在煮一鍋湯一樣，如果在煮湯前沒有把食材清洗、整理，那這鍋湯自然就不會美味。也就是說，錯誤的資料即使你用了再厲害的分析方法必然不能產生正確的結果</p><h2 id="常用資料分析函式庫"><a href="#常用資料分析函式庫" class="headerlink" title="常用資料分析函式庫"></a>常用資料分析函式庫</h2><ol><li>Numpy: <ul><li>進行基本陣列處理與數值運算的函式庫，能進行較進階複雜的運算，處理速度比Python裡的一般運算快速 </li></ul></li><li>Scipy: <ul><li>將Numpy的功能更進一步強化的函式庫</li><li>能進行統計與訊號運算</li></ul></li><li>Pandas:<ul><li>藉由<code>DataFrame</code>的形式來對各種資料進行加工的函式庫 </li></ul></li><li>Matplotlib:<ul><li>用於將資料視覺化的函式庫</li></ul></li></ol><h2 id="函式庫的匯入"><a href="#函式庫的匯入" class="headerlink" title="函式庫的匯入"></a>函式庫的匯入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br></pre></td></tr></table></figure><ul><li>以<code>np</code>這個識別名稱匯入Numpy模組。</li><li>以<code>np.功能名稱</code>來使用所提供的各種功能</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random    </span><br></pre></td></tr></table></figure><ul><li>原來必須以「模組名稱.功能名稱.功能名稱….」來使用函式</li><li>利用from來省略</li><li>np.random.功能名稱 = random.功能名稱 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Preprocessing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> lesson note </tag>
            
            <tag> Data preprocessing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -70. Climbing Stairs解題紀錄</title>
      <link href="/larry891001/2022/03/07/LeetCode/easy/ClimbingStairs/"/>
      <url>/larry891001/2022/03/07/LeetCode/easy/ClimbingStairs/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/climbing-stairs/">LeetCode - 70. Climbing Stairs</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>一開始還想不到到底該怎麼解，結果列了幾個數字，發現其實就是<code>Fibonacci Number</code>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>        </span><br><span class="line">        x, y, i = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i != n+<span class="number">1</span>:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> y </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -67. Add Binary解題紀錄</title>
      <link href="/larry891001/2022/03/04/LeetCode/easy/addbinary/"/>
      <url>/larry891001/2022/03/04/LeetCode/easy/addbinary/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/add-binary/">LeetCode - 67. Add Binary</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題非常簡單，只需要將兩個二進位數字相加就行了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format</span>(<span class="built_in">int</span>(a,<span class="number">2</span>)+<span class="built_in">int</span>(b,<span class="number">2</span>),<span class="string">&#x27;b&#x27;</span>)    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -66. Plus One解題紀錄</title>
      <link href="/larry891001/2022/03/03/LeetCode/easy/PlusOne/"/>
      <url>/larry891001/2022/03/03/LeetCode/easy/PlusOne/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/plus-one/">LeetCode - 66. Plus One</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題要求將此<code>digits</code>+1然後輸出，可是需要考慮進位的問題，但整體也不算是太難的題目。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        digits[-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i] &gt;= <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    digits[i] -= <span class="number">10</span></span><br><span class="line">                    digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                digits[i] -= <span class="number">10</span></span><br><span class="line">                digits[i-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -58. Length of Last Word解題紀錄</title>
      <link href="/larry891001/2022/03/03/LeetCode/easy/LengthofLastWord/"/>
      <url>/larry891001/2022/03/03/LeetCode/easy/LengthofLastWord/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/length-of-last-word/">LeetCode - 58. Length of Last Word</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題要找出最後一個字的長度不能為空格，所以我先利用<code>split</code>將<code>string</code>用<code>&quot; &quot;</code>切開，再從這個<code>list</code>的尾端開始遍歷陣列，直到找到第一個不會<code>&quot;&quot;</code>的字串。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(s[i])   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -53. Maximum Subarray解題紀錄</title>
      <link href="/larry891001/2022/03/02/LeetCode/easy/maximumSubarray/"/>
      <url>/larry891001/2022/03/02/LeetCode/easy/maximumSubarray/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/maximum-subarray/submissions/">LeetCode - 53. Maximum Subarray</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題是一個最大子數列的問題，這題有用到一個演算法<a href="https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d">Kadane’s Algorithm</a>詳細內容可以看這篇文章講得非常清楚</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        globalMax = nums[<span class="number">0</span>]</span><br><span class="line">        localMax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            localMax = <span class="built_in">max</span>(i,localMax+i)</span><br><span class="line">            globalMax = <span class="built_in">max</span>(globalMax,localMax)</span><br><span class="line">        <span class="keyword">return</span> globalMax</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -392. Is Subsequence解題紀錄</title>
      <link href="/larry891001/2022/03/02/LeetCode/easy/IsSubsequence/"/>
      <url>/larry891001/2022/03/02/LeetCode/easy/IsSubsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/is-subsequence/">LeetCode - 392. Is Subsequence</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題大概就類似<code>Longest common subsequence</code>，只是這題的<code>Longest common subsequence</code>就是<code>s</code>。可參考這篇<a href="http://web.ntnu.edu.tw/~algo/Subsequence2.html">LCS演算法</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        sindex,tindex = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        sizet,sizes = <span class="built_in">len</span>(t),<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> tindex &lt; sizet <span class="keyword">and</span> sindex &lt; sizes:</span><br><span class="line">            <span class="keyword">if</span> s[sindex] == t[tindex]:</span><br><span class="line">                tindex += <span class="number">1</span></span><br><span class="line">                sindex += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tindex += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sindex == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>       </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -35. Search Insert Position解題紀錄</title>
      <link href="/larry891001/2022/03/01/LeetCode/easy/SearcchInsertPosition/"/>
      <url>/larry891001/2022/03/01/LeetCode/easy/SearcchInsertPosition/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/search-insert-position/">LeetCode - 35. Search Insert Position</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題要求將在<code>nums</code>裡面尋找<code>target</code>，如果有找到就回傳<code>target</code>的位置，否則就回傳它應該在的位置。<code>nums</code>是按照升冪排列的，所以我就遍歷陣列去比較，找到符合的就回傳，中間如果遇到比它大的就代表找不到了，因為題目有說<code>nums</code>裡面都是不同的數字。 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[i]:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -338. Counting Bits解題紀錄</title>
      <link href="/larry891001/2022/03/01/LeetCode/easy/CountingBits/"/>
      <url>/larry891001/2022/03/01/LeetCode/easy/CountingBits/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/counting-bits/">LeetCode - 171. Excel Sheet Column Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目輸入<code>n</code>，要求輸出從<code>0~n</code>每一個數字的二進位有幾個1，窩先使用<code>format</code>這個function將10進位數字轉2進位，再利用<code>count</code>這個function去數有幾個1，然後把它<code>append</code>到<code>list</code>裡面</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        newlist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">format</span>(i, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">            newlist.append(temp.count(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> newlist</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -657. Robot Return to Origin解題紀錄</title>
      <link href="/larry891001/2022/02/24/LeetCode/easy/RobotReturntoOrigin/"/>
      <url>/larry891001/2022/02/24/LeetCode/easy/RobotReturntoOrigin/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/robot-return-to-origin/">LeetCode - 509. Fibonacci Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目說從(0,0)開始上下左右移動，移動後結果是否還會在(0,0)。因此，我利用計算上下移動的次數來判斷，若是往上的次數等於往下的次數而且往左的次數等於往右的次數，就代表移動後還是會在原地</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeCircle</span>(<span class="params">self, moves: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        d =&#123;<span class="string">&quot;U&quot;</span>:<span class="number">0</span>,<span class="string">&quot;D&quot;</span>:<span class="number">0</span>,<span class="string">&quot;L&quot;</span>:<span class="number">0</span>,<span class="string">&quot;R&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> moves:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> d:</span><br><span class="line">                d[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> d[<span class="string">&quot;U&quot;</span>] == d[<span class="string">&quot;D&quot;</span>] <span class="keyword">and</span> d[<span class="string">&quot;L&quot;</span>] == d[<span class="string">&quot;R&quot;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -344. Reverse String解題紀錄</title>
      <link href="/larry891001/2022/02/23/LeetCode/easy/ReverseString/"/>
      <url>/larry891001/2022/02/23/LeetCode/easy/ReverseString/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/reverse-string/">LeetCode - 344. Reverse String</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題要求將陣列中的元素相反，但有要求不能宣告其它的變數，我的方法是將<code>s</code>最後的元素再加上去，並且刪掉原本的，這樣就能達到<code>reverse</code>的效果</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size):</span><br><span class="line">            s.append(s[size-i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">del</span> s[size-i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -28. Implement strStr()解題紀錄</title>
      <link href="/larry891001/2022/02/23/LeetCode/easy/ImplementstrStr/"/>
      <url>/larry891001/2022/02/23/LeetCode/easy/ImplementstrStr/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/implement-strstr/">LeetCode - 28. Implement strStr()</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目只是說若<code>haystack</code>裡含有<code>needle</code>就回傳該位置，否則就回傳<code>-1</code>，但若<code>needle</code>為空就回傳<code>0</code>，</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> haystack.find(needle)               </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -27. Remove Element解題紀錄</title>
      <link href="/larry891001/2022/02/23/LeetCode/easy/RemoveElement/"/>
      <url>/larry891001/2022/02/23/LeetCode/easy/RemoveElement/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-element/">LeetCode - 27. Remove Element</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要求將特定的元素刪除，所以我們只需要遍歷<code>nums</code>陣列並將和<code>val</code>相等的元素移除即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -26. Remove Duplicates from Sorted Array解題紀錄</title>
      <link href="/larry891001/2022/02/22/LeetCode/easy/RemoveDuplicatesfromSortedArray/"/>
      <url>/larry891001/2022/02/22/LeetCode/easy/RemoveDuplicatesfromSortedArray/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">LeetCode - 26. Remove Duplicates from Sorted Array</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>此題要求要將陣列<code>nums</code>的重複元素刪除，並回傳刪除後的長度，所以我先利用<code>set</code>這個function將<code>nums</code>的元素列出並將它轉成<code>list</code>型態並<code>sort</code></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums[:] = <span class="built_in">list</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -171. Excel Sheet Column Number解題紀錄</title>
      <link href="/larry891001/2022/02/22/LeetCode/easy/ExcelSheetColumnNumber/"/>
      <url>/larry891001/2022/02/22/LeetCode/easy/ExcelSheetColumnNumber/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/excel-sheet-column-number/">LeetCode - 171. Excel Sheet Column Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要將<code>columnTitle</code>轉成對應的<code>colum number</code>，從Example中可以得知每一個位置都是有權重的。以”AAA”為例第一個A的權重為<code>1*26**2</code>，第二個為<code>1*26**1</code>，而第三個為<code>1*26**0</code>以此類推。因此，只要將每個位置的權重加起來就是答案了 </p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, columnTitle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dictt = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;H&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;N&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;O&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;P&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;R&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;T&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;U&#x27;</span>: <span class="number">21</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;W&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">24</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="number">26</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(columnTitle)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dictt[columnTitle]</span><br><span class="line">        priority = <span class="number">26</span></span><br><span class="line">        priority = math.<span class="built_in">pow</span>(priority,<span class="built_in">len</span>(columnTitle))</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> columnTitle:</span><br><span class="line">            priority /= <span class="number">26</span></span><br><span class="line">            <span class="built_in">sum</span> += dictt[i]*priority</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -205. Isomorphic Strings解題紀錄</title>
      <link href="/larry891001/2022/02/21/LeetCode/easy/IsomorphicStrings/"/>
      <url>/larry891001/2022/02/21/LeetCode/easy/IsomorphicStrings/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/isomorphic-strings/">LeetCode - 205. Isomorphic Strings</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>此題要求確認兩個字串s及t是否為同構，也就是說字串的某幾個位置是否都同為某個字元，例如s = “paper”, t = “title”，表示s和t的第1、3個位置都要是同個字元，若是成立則回傳True，反之，則回傳False。<br>所以可以用<code>str</code>的<code>find</code>來回傳指定字元的第一次出現時的<code>index</code>，並把兩者的<code>index</code>存進來做比較，若全部相同，則代表兩者為<code>Isomorphic Strings</code>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        slist = [s.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line">        tlist = [t.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> t]</span><br><span class="line">        <span class="keyword">return</span> slist == tlist                    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -682. Baseball Game解題紀錄</title>
      <link href="/larry891001/2022/02/21/LeetCode/easy/BaseballGame/"/>
      <url>/larry891001/2022/02/21/LeetCode/easy/BaseballGame/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/baseball-game/">LeetCode - 682. Baseball Game</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題很簡單，因為題目有說<code>+</code>前面一定會有兩個<code>scores</code>，<code>C</code>和<code>D</code>前面也至少也會有一個<code>score</code>，所以直接解就行了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calPoints</span>(<span class="params">self, ops: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        newlist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                newlist.pop()</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">                newlist.append(<span class="built_in">int</span>(newlist[-<span class="number">1</span>])*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                newlist.append(<span class="built_in">int</span>(newlist[-<span class="number">1</span>])+<span class="built_in">int</span>(newlist[-<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newlist.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> newlist:</span><br><span class="line">            <span class="built_in">sum</span> += <span class="built_in">int</span>(i)       </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -509. Fibonacci Number解題紀錄</title>
      <link href="/larry891001/2022/02/21/LeetCode/easy/FibonacciNumber/"/>
      <url>/larry891001/2022/02/21/LeetCode/easy/FibonacciNumber/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/fibonacci-number/">LeetCode - 509. Fibonacci Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題就是個<code>Fibonacci Number</code>的問題，有兩種解法一種是用<code>recursive</code>，也可以用<code>iterative</code>的方法。我是使用<code>recursive</code>的方法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fib(n-<span class="number">1</span>) + self.fib(n-<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.fib(n)  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -21. Merge Two Sorted Lists解題紀錄</title>
      <link href="/larry891001/2022/02/21/LeetCode/easy/MergeTwoSortedLists/"/>
      <url>/larry891001/2022/02/21/LeetCode/easy/MergeTwoSortedLists/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">LeetCode - 21. Merge Two Sorted Lists</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>題目要求要將兩個<code>sorted list</code>合併成一個list，首先先宣告一個新的<code>newlist</code>以及一個<code>newlistptr</code>指向<code>newlist</code>的指標，再來開始判斷<code>list1.val</code>及<code>list2.val</code>的大小，將<code>newlistptr.next</code>指向較小的那個值直到其中一個<code>list</code>為<code>None</code>。最後再將還沒指到<code>None</code>的list指完</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        newlist = ListNode()</span><br><span class="line">        newlistptr = newlist</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                newlistptr.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newlistptr.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span>  </span><br><span class="line">            newlistptr = newlistptr.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">None</span>:</span><br><span class="line">            newlistptr.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newlistptr.<span class="built_in">next</span> = l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newlist.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -20. Valid Parentheses解題紀錄</title>
      <link href="/larry891001/2022/02/19/LeetCode/easy/Valid%20Parentheses/"/>
      <url>/larry891001/2022/02/19/LeetCode/easy/Valid%20Parentheses/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/valid-parentheses/">LeetCode - 20. Valid Parentheses</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題需要用到<code>stack</code>也就是容器的概念，遇到<code>&quot;([&#123;&quot;</code>左括號一律推進<code>stack</code>裡面，遇到右括號就去判斷進來的這個右括號能不能跟<code>stack</code>中最上層的括號抵銷。如果最後<code>stack</code>中還有東西代表括號不能完全抵消，代表是不合法的，就return False，反之若<code>stack</code>為空就return True。<br><img src="https://img.onl/S69wZ4" alt="stack"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="built_in">dict</span>=&#123;<span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>,<span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> stack==[] <span class="keyword">or</span> <span class="built_in">dict</span>[stack.pop()]!=i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> stack==[]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -242. Valid Anagram解題紀錄</title>
      <link href="/larry891001/2022/02/18/LeetCode/easy/ValidAnagram/"/>
      <url>/larry891001/2022/02/18/LeetCode/easy/ValidAnagram/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/valid-anagram/">LeetCode - 242. Valid Anagram</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>先建立兩個字典<code>slist</code>,<code>tlist</code>分別存放兩個字的元素，使用<code>set</code>這個function可以將字串的所有元素列出，並讓它等於該元素出現的次數，若兩個字典相等就return True，否則就return False</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        slist, tlist = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            slist[i] = s.count(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">set</span>(t):</span><br><span class="line">            tlist[j] = t.count(j)</span><br><span class="line">        <span class="keyword">return</span> slist == tlist</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -14. Longest Common Prefix解題紀錄</title>
      <link href="/larry891001/2022/02/18/LeetCode/easy/LCP/"/>
      <url>/larry891001/2022/02/18/LeetCode/easy/LCP/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/longest-common-prefix/">LeetCode - 14. Longest Common Prefix</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>我先找出所有字串裡面最短的那個字，並將它定義為<code>compare</code>，先將<code>compare</code>字串下去跟其他字串做比較，每個字都從位置<code>0</code>檢查到<code>compare的長度-1</code>，如果完全符合的話就將<code>count+1</code>，若不符合就將<code>compare</code>的最後一個字母拿掉，繼續比較，直到<code>compare</code>為空或是<code>count</code>和所有字串的個數相同</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        minlen = <span class="built_in">len</span>(strs[<span class="number">0</span>])</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(i) &lt; minlen:</span><br><span class="line">                minlen = <span class="built_in">len</span>(i)</span><br><span class="line">                index = strs.index(i)</span><br><span class="line">        compare = strs[index]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> compare != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> strs:</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(compare)):</span><br><span class="line">                    <span class="keyword">if</span> i[j] != compare[j]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmp == <span class="built_in">len</span>(compare):</span><br><span class="line">                        count = count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="built_in">len</span>(strs):</span><br><span class="line">                <span class="keyword">return</span> compare</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                compare = compare[:-<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> compare</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -13. Roman to Integer解題紀錄</title>
      <link href="/larry891001/2022/02/18/LeetCode/easy/Romaninteger/"/>
      <url>/larry891001/2022/02/18/LeetCode/easy/Romaninteger/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/roman-to-integer/">LeetCode - 13. Roman to Integer</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>這題我先建立了兩個字典，一個是正常的<code>symbol dictionary</code>，另一個是<code>complex dictionary</code>也就是由兩個symbol所組成的，針對這兩個字典去做搜尋即可。先搜尋<code>complex</code>，搜尋完之後將它用空字元取代，之後再去搜尋<code>symbol</code></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        d = &#123;<span class="string">&quot;I&quot;</span>: <span class="number">1</span>, <span class="string">&quot;V&quot;</span>: <span class="number">5</span>, <span class="string">&quot;X&quot;</span>:<span class="number">10</span>, <span class="string">&quot;L&quot;</span>:<span class="number">50</span>, <span class="string">&quot;C&quot;</span>:<span class="number">100</span>, <span class="string">&quot;D&quot;</span>:<span class="number">500</span>, <span class="string">&quot;M&quot;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        cd = &#123;<span class="string">&quot;IV&quot;</span>:<span class="number">4</span>, <span class="string">&quot;IX&quot;</span>:<span class="number">9</span>, <span class="string">&quot;XL&quot;</span>:<span class="number">40</span>, <span class="string">&quot;XC&quot;</span>:<span class="number">90</span>, <span class="string">&quot;CD&quot;</span>:<span class="number">400</span>,<span class="string">&quot;CM&quot;</span>:<span class="number">900</span>&#125;</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cd:</span><br><span class="line">            <span class="keyword">if</span> s.find(i) &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">sum</span> += cd[i] </span><br><span class="line">                s = s.replace(i, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="built_in">sum</span> += d[i]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -9. Palindrome Number解題紀錄</title>
      <link href="/larry891001/2022/02/18/LeetCode/easy/Palindrome/"/>
      <url>/larry891001/2022/02/18/LeetCode/easy/Palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/palindrome-number/">LeetCode - 9. Palindrome Number</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>先將<code>x</code>變數由integer轉為string，建立另一個變數儲存<code>x</code>的相反數，並比較其是否相等</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        word = <span class="built_in">str</span>(x)</span><br><span class="line">        word1 = word[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> word == word1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode -1. TwoSum解題紀錄</title>
      <link href="/larry891001/2022/02/18/LeetCode/easy/TwoSum/"/>
      <url>/larry891001/2022/02/18/LeetCode/easy/TwoSum/</url>
      
        <content type="html"><![CDATA[<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://leetcode.com/problems/two-sum/">LeetCode - 1. TwoSum</a></p><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>遍歷<code>nums</code>陣列先用<code>target</code>減去該<code>nums</code>之後，接下來去尋找符合的數字，如果沒找到就繼續，如果有找到就將結果儲存並回傳</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp - nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    result.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一屆捷運盃黑客松-尋找黑捷客</title>
      <link href="/larry891001/2022/02/16/%E7%AB%B6%E8%B3%BD/metro/"/>
      <url>/larry891001/2022/02/16/%E7%AB%B6%E8%B3%BD/metro/</url>
      
        <content type="html"><![CDATA[<p>競賽(官網已失效)： <a href="https://2021hackathon.metro.taipei/">第一屆捷運盃黑客松-尋找黑捷客</a></p><h2 id="計畫說明"><a href="#計畫說明" class="headerlink" title="計畫說明"></a>計畫說明</h2><p><code>捷運趴趴GO</code> (亞軍)</p><h3 id="計畫緣起"><a href="#計畫緣起" class="headerlink" title="計畫緣起"></a>計畫緣起</h3><p>台北捷運的日運載量大約落在213萬人次，在大眾交通工具系統中位居首位，大多數人的年齡大約落在15-39歲之間的年輕族群，這類族群也以觀光旅遊為大宗。<br>依據台北捷運官方手冊的統計，台北捷運在2019年三月時運載量突破了100億人次，台北捷運是台北都會區700萬人口及900萬觀光客最仰賴的交通工具。<br>觀光對台北捷運來說是重要的一環，對於那些來台北捷運觀光的旅客而說，他們會不了解周邊有什麼景點，所以通常都會上網搜尋。以我們大學生來說，假日時，常常會和朋友到台北出遊，可是因為交通因素，我們通常會選擇搭乘捷運，行程規劃也會以捷運周邊為主，但網路上的文章及分享通常頁面混亂、內容零星，也常常找到過時的評論。而且這些內容通常已經從主動分享變成直接的業配，造成無公正性及缺乏可比較性。像我們面對大量的雜訊、廣告，無法獲取真實有意義的資訊。<br>我們想到兩個可能的原因部落客可能因為內容不易被看見且無法獲得相應的回饋而導致創作慾望降低，此外，創作這些內容時間成本也蠻高的。</p><h3 id="計畫目的"><a href="#計畫目的" class="headerlink" title="計畫目的"></a>計畫目的</h3><p>因此我們想要提供可以輕鬆生產內容且推廣的平台、減少重複內容的出現、將產出內容的價值充分回饋給創作者。並且除了讓用戶方便取用之外，也可以真實支持到內容創作者跟店家。<br>我們的產品內容主要提供三種服務，首先第一個部分為旅遊推薦，藉由大家的分享讓旅客能找到適合自己的行程。再來是記錄行程，能夠將自己的旅程自動記錄下來，並分享到我們所設計的App上。最後是回饋機制，有良好的回饋機制能夠使創作者的動力提高。</p><h2 id="計畫構想"><a href="#計畫構想" class="headerlink" title="計畫構想"></a>計畫構想</h2><h3 id="計畫功能"><a href="#計畫功能" class="headerlink" title="計畫功能"></a>計畫功能</h3><ul><li>一打開App首先會看見我們系統所推薦的熱門行程，點選某一個行程後，會出現行程路線及交通工具</li><li>記錄行程的方式，先掃描車站QR Code啟動App並開始記錄，記錄行程時會自動記錄時間(系統時間)、地點(定位)以及判斷到達方式，回到車站再掃描一次QR Code結束紀錄並進入編輯行程頁面</li><li>結束紀錄之後，可以看到系統自動記錄的行程，即可進行編輯，例如: 增加景點，編輯時間、到達方式</li><li>再來是我們的特色AR導航，我們會在使用者導航的過程中，顯示商家的資訊以及限時優惠</li><li>我們想到可以在捷運站裡設置電子看板，能讓旅客與看板互動，看板的畫面是我們App的首頁，旅客可以掃描上方的QR Code進入我們的App，也可以掃描行程的QR Code進入行程畫面，最下方的兩個QR Code分別是紀錄行程跟結束紀錄</li></ul><h3 id="使用對象"><a href="#使用對象" class="headerlink" title="使用對象"></a>使用對象</h3><ul><li><p>生產者情境: 有一位Willy Wu他是一位旅遊達人喜歡分享自己的行程，但他的文章觸及率過低導致他沒有動力繼續創作，因此我們推薦他我們的App並教他如何使用<br>首先當他想要記錄旅程時，可以在捷運站掃描Qr Code啟動App開始記錄，過程中所記錄下來的軌跡會自動記載路程、所使用的交通方式以及停留的商家。回到車站或是到了別的站點可以掃碼結束旅程，並且在後續可以重新編輯路徑，刪除或新增站點，並且給予不同的站點推薦的指數與標籤。並進一步決定要公開共享路線或是私人傳遞給朋友。</p></li><li><p>使用者情境: 有一位Tiffany Green他喜歡城市旅遊，這次他到台北出差想順便在附近晃晃，但網路上的資料過時又龐大，他很難找到自己想要的行程，因此，我們向他介紹我們的App，首先他可以在捷運站裡的電子看板上或是打開我們的App搜尋想要的行程，找到想要的行程之後，按下導航鍵啟動旅程，導航過程中會顯示商家的資訊以及所提供的限時優惠，提供給旅客來做參考與使用。</p></li></ul><h2 id="計畫角色"><a href="#計畫角色" class="headerlink" title="計畫角色"></a>計畫角色</h2><p>我們APP的角色互動將分成4個部分生產者(旅遊達人)、使用者(旅客)、商家、捷運趴趴GO</p><ul><li>旅遊達人(旅程生產者): 旅遊達人透過親自造訪體驗，進而將旅遊經驗分享至平台上，以供遊客參考。若該行程得到不錯的反應，旅遊達人可以得到相對應的GOGO point也能獲得商家的廣告收益，讓創作動力提高</li></ul><ul><li>遊客(旅程消費者): 遊客可透過App或是電子看板選擇旅遊達人所分享行程，找到喜歡的行程後選擇導航可在路途中隨時接到商家資訊及限時優惠，如果喜歡這個行程，可以給旅遊達人按讚支持。</li></ul><ul><li><p>店家: 可以跟捷運趴趴GO合作，在電子看板上設置廣告來增加他的曝光度。在遊客導航中會設置限時優惠。那也會因旅客的按讚支持而間接的回饋給旅遊達人。</p></li><li><p>捷運趴趴GO: 為旅遊達人與遊客提供一個平台使用，結合捷運路線圖，透過旅遊達人的分享，給予遊客相對應的行程選擇。商家也多了一個平台能夠打廣告提高曝光度，捷運可以和趴趴GO合作。</p></li></ul><h2 id="計畫實現"><a href="#計畫實現" class="headerlink" title="計畫實現"></a>計畫實現</h2><p>App的前端我們預計會使用Flutter，後端使用Firebase做連接，導航部分會用Google Map API + ARcore，我們智能服務都是從後端伺服器的API做處理。</p><h2 id="效益評估"><a href="#效益評估" class="headerlink" title="效益評估"></a>效益評估</h2><ul><li>對於目前市場上兩個相似的產品funliday 及 gogoeasy，我們的產品在記錄行程此方面是全自動記錄的 可以省下不少時間及心力，旅程的景點是環繞捷運去做規劃的，捷運站關聯性會相較其他兩個來說還要高 且會給予旅遊達人點數回饋，我們也會和商家進行一些合作關係。</li><li>我們的廣告方式相較於其他雖然觸及範圍小但精準度高，適合捷運周邊商家，對於商家投放廣告上我們做了一些分析，捷運站內有著各式各樣的廣告，這些廣告雖然觸及大但是精準度卻是極低，對於商家來說想要投放這種廣告幾乎是遙不可及的，觀光客自然而然也無法輕易地接收到捷運附近商家的資訊，因此我們提供平台讓合作商家投放資訊給旅客，藉此媒合他們，當商家數量眾多時，其實可以創造和大公司一樣的效益，這邊是我們跟現有的廣告方式做比較，雖然我們的觸及範圍較小，但我們的觸及精準度和即時性會更高。</li></ul><div class="note primary modern"><p>GOGO point 主要就是由旅客的按讚數所得到的點數回饋 它可以兌換商家的優惠或是換取捷運的搭乘折扣</p></div><h2 id="計畫原型"><a href="#計畫原型" class="headerlink" title="計畫原型"></a>計畫原型</h2><p><a href="https://www.figma.com/proto/o7Ht8VZm2m0V7FOG2zyuw6/%E6%8D%B7%E9%81%8B%E8%B6%B4%E8%B6%B4go?node-id=10:2&scaling=scale-down&starting-point-node-id=10:2&show-proto-sidebar=1">FigmaPrototype</a></p><h2 id="決賽評審QA"><a href="#決賽評審QA" class="headerlink" title="決賽評審ＱＡ"></a>決賽評審ＱＡ</h2><ol><li>若是使用者有惡意行為出現，如何解決？（例如買榜）<br>我們可以採用兩種方式解決：1. 使用身份驗證及按讚行為的異常偵測，2. 使用類似medium平台的按愛心機制（每個帳號有一定額度的按讚度，再讓按讚度去除以按讚數則為該帳號一個讚的權重，則若是該帳號按讚越多，權重越低）</li><li>初期怎麼讓旅遊專家有動機，如何開啟整個生態圈？<br>花錢開啟生態圈是必然的，初期我們可以和熱門的部落格合作，請他們將旅程發布在平台上開啟整個生態圈。</li><li>著名平台kkday也是旅遊的平台，你們有何差異？<br>kkday內的旅程多屬於需開車到達的地方，而我們平台內的旅程均會圍繞整個捷運進行，因此我們平台內推送的行程對於捷運的黏著度會較kkday高出非常多。</li></ol><p>（還有一些問題忘記拉嗚嗚…)</p><h2 id="決賽簡報"><a href="#決賽簡報" class="headerlink" title="決賽簡報"></a>決賽簡報</h2><p><a href="/img/article/go/%E6%8D%B7%E9%81%8B%E8%B6%B4%E8%B6%B4GO.pptx">pdf</a></p><h2 id="相關報導"><a href="#相關報導" class="headerlink" title="相關報導"></a>相關報導</h2><ol><li><a href="https://www.cse.yzu.edu.tw/news/others?id=56">捷運盃黑客松-尋找黑捷客 - 元智資工獲亞軍</a></li><li><a href="https://tw.stock.yahoo.com/news/%E5%8C%97%E6%8D%B7%E9%A6%96%E5%B1%86%E5%B0%8B%E6%89%BE%E9%BB%91%E6%8D%B7%E5%AE%A2%E5%89%B5%E6%84%8F%E7%AB%B6%E8%B3%BD%E5%86%A0%E8%BB%8D%E6%8F%AD%E6%9B%89-115318930.html">北捷首屆尋找黑捷客創意競賽冠軍揭曉</a>（照片錯放錯啦嗚嗚嗚）</li><li><a href="https://www.cdns.com.tw/articles/507990">北捷首屆尋找黑捷客創意競賽冠軍揭曉</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google map API </tag>
            
            <tag> contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poisson Image Blending</title>
      <link href="/larry891001/2021/11/05/PoissonImage/"/>
      <url>/larry891001/2021/11/05/PoissonImage/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>本篇文章主要講解2004年Siggraph的經典paper：《Poisson Image Editing》，在圖像融合領域，融合效果最牛逼的paper。講這個算法，我沒打算講太多理論的公式，理論的東西，對於大部分數學比較差的人來說看了就頭暈。什麼散度、拉普拉斯算子、梯度場、泊松方程、泊松方程第一類邊界條件(Dirichlet boundary)、泊松方程第二類邊界條件(Neumann boundary)，如果把這些公式貼上來，估計很多人還沒看到算法是怎麼實現的，就已經看不下去了。因此我將直接給出離散形式實現方法，算法流程。</p><p>開始這個算法前，我需要先講解一個數學問題：</p><ol><li><p>散度計算:</p><ul><li>什麼是散度和梯度?<ul><li>梯度：運算對像是標量，計算結果是向量<br>計算梯度時會在每個位置都計算出一個向量，這個向量的方向是當前位置周圍的標量值最小點指向標量值最大點（這個周圍其實是極其接近的，相當於取極限），而向量的大小就是上面最小標量與最大標量的差距。想像給山求梯度，山上每個點都有一個向量，每個向量都指向最陡的方向，向量大小代表這個最陡的方向有多陡。</li><li>散度：運算對像是向量，計算結果是標量<br>散度考察向量場中任何一個點及其周圍極小極小的一塊區域，在該點上，這個極小區域向量場的發散程度。<br>【其實梯度和散度都是一種基於 local 的量，考察的都是任何一點及其周圍很小很小的一個範圍】<br>散度是作用在向量場的一個算子，通過對一個向量場計算散度，能夠得到一個標量場，也就是說，在向量空間中每一點的散度都是一個標量。<br>散度表徵的是向量場的發散程度<br>散度 &gt; 0，表明向量場向外發散<br>散度 = 0，表明向量場內外平衡<br>散度 &lt; 0，表明向量場向內聚集</li></ul></li><li>散度計算<br>現在假設一幅圖像為3*3的單通道灰度圖像：<br><img src="data:image/png;base64,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" alt="3X3Image"></li></ul><p> 我們假設每一點的像素值為V，V(1)表示像素點1的值，那麼我們可以定義像素點5的散度的計算公式為：<br> div(5)=[V(2)+V(4)+V(6)+V(8)]-4*V(5)<br> 說白了就是通過拉普拉斯卷積核，進行卷積，就可以求解散度了。<br> <img src="https://lh3.googleusercontent.com/7HV_0XjZrnUhApKxHqvSIaPfQJoVNQ4ibKLvvjI6PCDCOm2Goirs5GQzOdxUAyfh2OLI=s107" alt="Result"><br> 當然正規的過程應該是先求解像素點5的梯度值，然後在對梯度求導，這樣就能得到散度，不過得到的結果其實就是上面的計算公式。</p></li><li><p>柏松重建<br> 如果給定每個像素點的散度，我要你求解每個像素點的值，要怎麼求取。這便是泊松方程的靈魂了。為了更好的理解重建過程，我現在假設圖像的大小是4*4的16個像素點圖片，如下：<br> <img src="data:image/png;base64,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" alt="4X4Image"></p><p> 假設我給你像素點6、7、10、11的散度值div(6)、div(7)、div(10)、div(11)，那麼我們是不是可以列出如下4個方程：</p><p> [V(2)+V(5)+V(7)+V(10)]-4*V(6)=div(6)</p><p> [V(3)+V(6)+V(8)+V(11)]-4*V(7)=div(7)</p><p> [V(6)+V(9)+V(11)+V(14)]-4*V(10)=div(10)</p><p> [V(7)+V(10)+V(12)+V(15)]-4*V(11)=div(11)</p><p> 這個時候，如果我們只有四個方程，可是裡面有16個像素點，也就是說有16個未知數。因此單單靠上面的4個方程，就想把所有的像素值求解出來是不可能的，這樣方程有無數多個解。因此我們需要添加約束方程，這個便是泊松重建方程的約束條件了。假設我們添加邊界約束條件，也就是說如果我已經知道了上面那副圖像最外圍一圈的每個像素點的值u，這樣我們就可以得到12個約束方程。即：</p><p> V(1)=u(1)                V(2)=u(2)     V(3)=u(3)</p><p> V(4)=u(4)                V(5)=u(5)      V(8)=u(8)</p><p> V(9)=u(9)             V(12)=u(12)      V(13)=u(13)</p><p> V(14)=u(14)           V(15)=u(15)V(16)=u(16)</p><p> 上面有12個方程，外加給定的散度4個方程，這樣我們有16個方程。這樣就可以求解方程組了，這樣就能實現通過散度+邊界約束條件，實現圖像重建。這個便是泊松方程的主要過程。<br> 因此泊松融合，說的再簡單一點，就是構建方程組：</p><pre><code> Ax=b</code></pre></li><li><p>泊松圖像融合<br> 泊松重建，其實就是求解方程組：</p><pre><code> Ax=b</code></pre><p> 算法的整個過程在於求解係數稀疏矩陣A、及b。只要A、b求出來了，那麼我們就可以求解方程組得到x，而x就是我們得到的融合結果的像素顏色值。<br> 因此當時我想當然的以為，b的求解直接用拉普拉斯卷積核對源圖像的興趣區域(ROI)，進行卷積就可以得到散度b的值，因為對於給定的一幅圖像散度其實就是通過拉普拉斯卷積核進行卷積，得到的結果，就是每個像素點的散度。這種思路本沒有錯，然而這樣會出現邊界過渡不自然的現象。<br> 而正確的思路應該是：求解ROI的梯度場Isrc，及背景圖像不被修改的像素區域的梯度場Idst。然後通過Isrc+Idst得到整幅待重建圖像的梯度場，最後才根據梯度場求解散度。所以千萬不要偷懶，不要一步求解散度，要先把待重建圖像的梯度場求好，再進行求解散度。</p></li><li><p>範例及程式碼<br> 先給定一張圖g<br> <img src="data:image/png;base64,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" alt="g"></p><p> 還有一張背景圖S</p> <img src = "https://lh3.googleusercontent.com/_8cwtqcnyDu7BOgV7hvOFNWDllkeidfuY_krcUHW1TLHCGtVz36Haq7cayUtrUggraGs=s85" height="150px" width="150px"><p> 目標:將g黏貼到S中，並呈現自然的效果</p> <img src = "https://lh3.googleusercontent.com/uo-ncesG9m6PwJyWEon4kwMvB146cHObQ4WBcMRHSAMbK8XTzF_08VRkXnXgJP7W7dmr=s86" height="150px" width="150px">  步驟1、計算圖像g的梯度場<p> 步驟2、計算背景圖片的梯度場</p><p> 步驟3、計算融合圖像的梯度場</p><p> 步驟4、求解融合圖像的散度</p><p> 步驟5、求解係數矩陣</p></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>直方圖匹配 Histogram Matching</title>
      <link href="/larry891001/2021/10/23/OpenCV/HistogramMatching/"/>
      <url>/larry891001/2021/10/23/OpenCV/HistogramMatching/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><h2 id="什麼是Histogram-Matching"><a href="#什麼是Histogram-Matching" class="headerlink" title="什麼是Histogram Matching?"></a>什麼是Histogram Matching?</h2><p><img src="https://929687.smushcdn.com/2407837/wp-content/uploads/2021/01/opencv_histogram_matching_cdf.png?lossy=1&strip=1&webp=0" alt="HM"></p><ul><li>Histogram matching是一種”transformation”，我們的目標是要將input(“source”) image的histogram distribution<br>與reference image的histogram distribution match起來，並且更新input image的pixel intensities。<br>For example, suppose we have an input image and a reference image. Our goal is to:<ol><li>Compute histograms for each image</li><li>Take the reference image histogram</li><li>Update the pixel intensity values in the input image using the reference histogram, such that they match</li></ol></li><li>Example<br><img src="https://929687.smushcdn.com/2407837/wp-content/uploads/2021/01/opencv_histogram_matching_output.png?lossy=1&strip=1&webp=0" alt="ex"></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>灰階直方圖均化 Histogram Equalization</title>
      <link href="/larry891001/2021/10/15/OpenCV/HE/"/>
      <url>/larry891001/2021/10/15/OpenCV/HE/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><h2 id="灰階直方圖-Histogram"><a href="#灰階直方圖-Histogram" class="headerlink" title="灰階直方圖 Histogram"></a>灰階直方圖 Histogram</h2><ol><li><p>何謂Histogram?</p><ul><li>“Histogram”中文叫作<strong>直方圖</strong>，方便人看出統計結果。</li></ul></li><li><p>影像上的Histogram</p><ul><li>而在影像上，我們會應用於統計一張圖片裡面各灰階值出現的頻率。<br><img src="https://jason-chen-1992.weebly.com/uploads/1/0/8/5/108557741/histogram_orig.jpg" alt="Histogram"><br>從上圖就可以看出來，將一張圖統計成Histogram 後，我們很容易的就可以知道這張影像的灰階值分佈。<br>於似乎就能很輕易的觀察這張影像整體偏暗或偏亮(即分佈靠左或靠右)，而再對它進行調整。</li></ul></li></ol><h2 id="均衡化-Equalization"><a href="#均衡化-Equalization" class="headerlink" title="均衡化 Equalization"></a>均衡化 Equalization</h2><ol><li>何謂Equalization?<ul><li>在Histogram的分佈中我們可以觀察到，如果Histogram分佈的峰值<strong>靠近左側(靠近0)<strong>，則代表這張影像</strong>偏暗</strong>；如果Histogram分佈的峰值<strong>靠近右側(靠近255)<strong>，則代表這張影像</strong>偏亮</strong>；如果 Histogram分佈的峰值非常集中在中間，則明暗的對比就不太明顯。Histogram最理想分佈狀況就是平均分佈，而這就是我們接下來要介紹的 Equalization。<br><img src="https://jason-chen-1992.weebly.com/uploads/1/0/8/5/108557741/histogrammeinebnung_orig.png" alt="Equlization"><h6 id="由Zefram-自己的作品-公有領域-https-commons-wikimedia-org-w-index-php-curid-668605"><a href="#由Zefram-自己的作品-公有領域-https-commons-wikimedia-org-w-index-php-curid-668605" class="headerlink" title="由Zefram - 自己的作品,公有領域, https://commons.wikimedia.org/w/index.php?curid=668605"></a>由Zefram - 自己的作品,公有領域, <a href="https://commons.wikimedia.org/w/index.php?curid=668605">https://commons.wikimedia.org/w/index.php?curid=668605</a></h6>上圖的 Transition function ( T )利用的是：累積分佈函數(Cumulative Distribution Function , CDF)<br>而所謂的 CDF 其實就是 機率密度函數(PDF) 的積分。<br>在數位(Digital)影像中(離散)，積分就是相加，所以我們可以整理出實作步驟如下：<ol><li>Source Image -&gt; Histogram</li><li>利用 Histogram 算出各個灰階值的 PDF</li><li>將PDF做累加求出CDF</li><li>將CDF的結果4捨5入後做出對照表</li><li>透過查詢剛剛建立的對照表，決定Transition完各個灰階值的機率<br><img src="https://jason-chen-1992.weebly.com/uploads/1/0/8/5/108557741/histogram-equalization_1_orig.jpg" alt="Equlization"></li></ol></li></ul></li></ol><h2 id="實例"><a href="#實例" class="headerlink" title="實例"></a>實例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;XXX.jpg&quot;</span></span><br><span class="line">img = cv2.imread(img_path)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img = cv2.equalizeHist(img)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;Histogram Equlization&#x27;</span>,  img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://jason-chen-1992.weebly.com/uploads/1/0/8/5/108557741/h-e-test_orig.jpg" alt="example"></p></div><div class="note simple"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jason-chen-1992.weebly.com/home/-histogram-equalization">【影像處理】灰階直方圖均化 Histogram Equalization</a></p></div>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV亮度與對比度的調整</title>
      <link href="/larry891001/2021/10/15/OpenCV/OpenCvAdjust/"/>
      <url>/larry891001/2021/10/15/OpenCV/OpenCvAdjust/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><h2 id="何謂亮度與對比度"><a href="#何謂亮度與對比度" class="headerlink" title="何謂亮度與對比度"></a>何謂亮度與對比度</h2><p>亮度調整：圖像像素強度整體變高/變低。</p><p>對比度調整：圖像暗處像素強度變低，圖像亮處像素強度變高，從而拉大中間某個區域範圍的顯示精度</p><h2 id="Opencv關於對比度與亮度的示例"><a href="#Opencv關於對比度與亮度的示例" class="headerlink" title="Opencv關於對比度與亮度的示例"></a>Opencv關於對比度與亮度的示例</h2><p>目前，網絡上大部分使用opencv調整圖像對比度和亮度的文章，基本都是源於官網的示例</p><p>映射曲線公式為g(x) = a*f(x)+b</p><p>對比度：<strong>需要通過a 、b 一起控制</strong>（僅調整a只能控制像素強度0附近的對比度，而這種做法只會導致像素強度大於0的部分更亮而已，根本看不到對比度提高的效果)</p><p>亮度：通過b控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> nps</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># numpy對數據溢出的處理250+10 = 260 =&gt; 260%256=4，</span></span><br><span class="line"><span class="comment"># 不適用於圖像處裡，所以用 np.clip()函數將數據限定：a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</span></span><br><span class="line">res = np.uint8(np.clip((<span class="number">1.5</span> * img + <span class="number">10</span>), <span class="number">0</span>, <span class="number">255</span>)) </span><br><span class="line"><span class="comment"># 兩張圖片橫向合並（便於對比顯示）</span></span><br><span class="line">tmp = np.hstack((img, res))  </span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>, tmp)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv4: Optimal Speed and Accuracy of Object Detection</title>
      <link href="/larry891001/2021/10/09/Yolov4/"/>
      <url>/larry891001/2021/10/09/Yolov4/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><h2 id="Object-Detection-物件偵測"><a href="#Object-Detection-物件偵測" class="headerlink" title="Object Detection(物件偵測)"></a>Object Detection(物件偵測)</h2><p>在電腦視覺物件偵測中，一般作法都是先用特殊方法先選出物件，比如Selective Search，選出物件的過程稱為Region Proposal；然後針對選出的物件(Region Proposals)再進行物件辨識 (但因為選出的物件大小可能不一樣，所以物件辨識有可能只有分類，也可能包含特徵擷取加分類)。這種需要先找出Region Proposal然後再做辨識的做法通常就稱為two stage learning。</p><h4 id="Two-Stage"><a href="#Two-Stage" class="headerlink" title="Two Stage:"></a>Two Stage:</h4><p>two stage的方法通常有一個問題是如果選出來的物件太多，假設一張圖選出一千個物件，後面的辨識就用重複做一千次(如下圖)，假設辨識的部分用了一個很複雜的辨識系統，比如一個物件辨識要0.1秒，那一千個物件就要100秒了，除非你用一個很強的GPU平行運算，那還可能減低運算時間，但如果是手機這類型的算法幾乎沒辦法做到即時運算，因此才有one stage的方法。<br>例如: R-CNN, Fast-RCNN , Faster-RCNN<br><img src="https://miro.medium.com/max/1400/1*layE--ElHj4u3J3YJFjmYA.png" alt="Two-Stage"></p><h4 id="One-Stage"><a href="#One-Stage" class="headerlink" title="One Stage:"></a>One Stage:</h4><p>物件位置偵測和物件辨識一步到位，也就是一個神經網路能同時偵測物件位置也可以辨識物件，如同Google在2015年12月提出Single Shot Detector (SSD)，Google在文章摘要第一句話就寫「We present a method for detecting objects in images using a single deep neural network.」，一個深度神經網路就可以做完所有的物件偵測。這種方式通常速度很快，但整體辨識精度可能沒有two stage的方法來的好，但整體辨識率仍在可接受範圍內，因此One stage的方法是目前比較多人研發用在行動裝置上的方法。<br>例如:YOLO (You only look once)系列: YOLOv1, YOLOv2, YOLOv3, Tiny YOLO, Single Shot Detector (SSD)<br><img src="https://miro.medium.com/max/1400/1*-9X-Fw6IHTAkCcGCwS5tgQ.png" alt="One-Stage"></p></div><div class="note modern"><h2 id="Abstract摘要"><a href="#Abstract摘要" class="headerlink" title="Abstract摘要"></a>Abstract摘要</h2><p>隨著深度學習的發展，目前已經出現了很多算法（或者訓練技巧，tricks）來提升神經網絡的準確率。在實際測試中評價一個算法的好壞優劣主要看兩點，一是能否在大規模的數據集中起作用（work），二是是否有理論依據。一些算法僅能在某些特定的模型上或者某類特定的問題上運行，亦或是適用於一些小規模的數據集。然而，還有一些算法，例如batch normalization（BN）或者殘差連接（residual-connections）已經被用在了不同的模型，任務以及不同的數據集中，已經被充分的證明了這些算法的普適性，是一個general的算法。我們假設這樣的general（or universal）的算法包括Weighted-residual-connection（WRC），cross-stage-partial-connections（SCP），cross mini-batch Normalization（CmBN），self-adversarial-training（SAT）以及mish-activation。此外，我們還加了一些其餘的tricks，包括Mosaic data augmentation，DropBlock regularization，CIoU loss，設計了一個YOLO-V4，並且在MS coco數據集中取得了新的state-of-the-art的結果：在Tesla V100顯卡能達到43.5% AP（65.7% AP50）的精度，且達到~65FPS的速度。目前代碼已經開源：<a href="https://github.com/AlexeyAB/darknet">OpenSource</a></p><h4 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h4><ul><li>Batch Normalization(BN):<br>BN的作用就是你輸入的資料進行標準化，降低scale的差異至同一個範圍內。這樣做的好處在於一方面提高梯度的收斂程度，加快訓練速度；另一方面使得每一層可以儘量面對同一特徵分佈的輸入值，減少了變化帶來的不確定性，也降低了對後層網路的影響，各層網路變得相對獨立。</li><li>Residual-connections:<br>在一定程度上，網絡越深表達能力越強，性能越好。不過，隨着網絡深度的增加，帶來了許多問題，梯度消散，梯度爆炸；Residual-connections(skip connect)改善了反向傳播中的梯度消散問題</li></ul></div><div class="note modern"><h2 id="AP指標"><a href="#AP指標" class="headerlink" title="AP指標"></a>AP指標</h2><ul><li>mAP: AP(average precision) 是用來評估物體識別模型效能表現的指標之一。<br><img src="https://i.imgur.com/KgFbe8Y.png" alt="Example"><br>假設我現在要從一些含有各種物體的影像中找出狗的圖片，那麼上圖左側深灰色矩形代表狗的圖片集合，右側淺灰色影像代表其他物體的圖片集合，中間的大圓圈則是被判定為狗的圖片的集合，其中包含真的為狗的圖片 (分類正確) 以及不是狗的圖片 (分類錯誤)。所以 precision 就代表在「所有被判定為狗的圖片」之中有多少比例是「狗的圖片」。<br>至於 average precision 的計算則是將 precision 加總後取平均值，又物體識別會有許多類別，以 COCO 資料集而言就有 80 種 object categories，mean average precision 便是所有類別 AP 加總的平均值。</li><li>IoU: IoU (Intersection over Union，並交比)，簡而言之，物體識別的 IoU 為物體標記範圍與系統偵測範圍這兩個集合的交集和並集之間的比例<br><img src="https://i.imgur.com/w7sc0Vc.jpg" alt="IoU"><br>假設紅框為影像的原始標記邊界範圍a1，黃框為 YOLO 所偵測的物體邊界範圍 a2，那麼 IoU 則為 a1 與 a2 的交集除以 a1 與 a2 的聯集。</li></ul><p>因此以 COCO 資料集的 AP 指標而言，可以看到其 IoU 並非一個固定值，而是「.50:.05:.95」，意思是 IoU 共有 {0.5, 0.55,…0.95} 10 個閾值，以這 10 個標準做判定、計算 AP 再取平均，而 AP50(IoU=.50) 或 AP75 (IoU=.75) 則是傳統的評估方式。</p><p><img src="https://user-images.githubusercontent.com/4096485/82835867-f1c62380-9ecd-11ea-9134-1598ed2abc4b.png" alt="YOLOv4-Precision"></p></div>}<div class="note modern"><h2 id="Introduction介紹"><a href="#Introduction介紹" class="headerlink" title="Introduction介紹"></a>Introduction介紹</h2><p>Yolo-V4的主要目的在於設計一個能夠應用於實際工作環境中的快速目標檢測系統，且能夠被並行優化，並沒有很刻意的去追求理論上的低計算量（BFLOP）。同時，Yolo-V4的作者希望算法能夠很輕易的被訓練，也就是說擁有一塊常規了GTX-2080ti或者Titan-XP GPU就能夠訓練Yolo-V4, 同時能夠得到一個較好的結果。</p><ul><li>研究設計了一個簡單且高效的目標檢測算法，該算法降低了訓練門檻，使得普通人員在擁有一塊1080TI或者2080TI的情況下就能夠訓練一個super fast and accurate 的目標檢測器</li><li>在訓練過程中，驗證了最新的Bag-of-Freebies和Bag-of-Specials對Yolo-V4的影響</li><li>簡化以及優化了一些最新提出的算法，包括（CBN，PAN，SAM），從而使Yolo-V4能夠在一塊GPU上就可以訓練起來。</li></ul></div><div class="note modern"><h2 id="Related-work相關研究"><a href="#Related-work相關研究" class="headerlink" title="Related work相關研究"></a>Related work相關研究</h2><p><img src="https://pic1.zhimg.com/80/v2-1d0fdcf7661cf0aca5fe8bf129604908_720w.jpg" alt="OjbectDetector"><br>Input：算法的輸入，包括整個圖像，一個patch，或者是image pyramid</p><p>Backbone：可以理解為是提取圖像特徵的部分，由於圖像中的淺層特徵（low-level）是比較類似的，例如提取邊緣，顏色，紋理這些。因此這部分可以很好的借鑒一些設計好並且已經訓練好的網絡，例如（VGG16,19，ResNet-50, ResNeXt-101, Darknet53）, 同時還有一些輕量級的backbone（MobilenetV1,2,3 ShuffleNet1,2）。</p><p>Neck：前面的backbone已經提取到了一些相關的淺層特徵，由這部分對backbone提取到的淺層特徵（low-level feature）進行加工，增強，從而使得模型學到的特徵是我想要的特徵。這部分典型的有（SPP，ASPP in deeplabV3+，RFB，SAM），還有一些（FPN, PAN, NAS-FPN, BiFPN, ASFF, SFAM）。</p><p>Head：檢測頭。這部分就到了算法最關鍵的部分，就是來輸出你想要的結果，例如想得到一個heatmap，（如在centernet中），那就增加一些反捲積層來一層一層反捲積回去。如果想直接得到bbox，那就可以接conv來輸出結果，例如Yolo，ssd這些。亦或是想輸出多任務（mask-RCNN）那就輸出三個head：classification，regression，segmentation（就是mask那部分）。</p><p>因此，一個檢測算法可以理解為：<br>Object Detection = Backbone + Neck + Head</p></div><div class="note modern"><h2 id="Bag-of-Freebies"><a href="#Bag-of-Freebies" class="headerlink" title="Bag-of-Freebies"></a>Bag-of-Freebies</h2><ul><li>Bag-of-Freebies:<br>  <strong>不會對測試過程的時間造成影響的方法</strong>。在目標檢測中是指：用一些比較有用的訓練技巧來訓練模型，從而使得模型取得更好的準確率但是不增加模型的複雜度，也就不增加推理（inference）是的計算量（cost）。在目標檢測中，提到bag of freebies，首先會想到的就是Data augmentation。<ul><li>Data Augmentation:<br>  目的在於增加訓練樣本的多樣性，使得檢測模型具有高的穩健性。常見的不能再常見的數據增強方式包括兩個方面：幾何增強以及色彩增強Pixel-Wise的調整<ul><li>幾何增強包括：隨機翻轉（水平翻轉較多，垂直翻轉較少），隨機裁剪（crop），拉伸，以及旋轉。</li><li>色彩增強包括：對比度增強，亮度增強，以及較為關鍵的HSV空間增強。<br>下述方法用來解决目標遮擋以及不足的問題</li><li>在圖像中隨機裁剪矩形區域，並用0來填充（random erase和CutOut算法）</li><li>隨機裁剪多個矩形區域（hide-and-seek， grid mask）</li><li>上述算法是在圖像中裁剪矩形區域並填充0，那麼算法在heatmap上裁剪並填充的叫做（DropOut，DropConnect， DropBlock）<br>此外還有一個重要的data augmentation算法叫做MIX-UP。 Mix-up在分類任務中，將兩個圖像按照不同的比例相加，例如A * 0.1+B * 0.9=C，那麼C的label就是[0.1A， 0.9B]。在目標檢測中的做法就是將一些框相加，這些label中就多了一些不同置信度的框。<br><img src="https://pic1.xuehuaimg.com/proxy/csdn/https://img-blog.csdnimg.cn/20190323235029958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nbGlhbmxt,size_16,color_FFFFFF,t_70" alt="MIXUP"></li></ul></li></ul></li></ul></div><div class="note modern"><h2 id="Bag-of-Specials"><a href="#Bag-of-Specials" class="headerlink" title="Bag-of-Specials"></a>Bag-of-Specials</h2></div><div class="note simple"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://chih-sheng-huang821.medium.com/%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E4%BB%80%E9%BA%BC%E6%98%AFone-stage-%E4%BB%80%E9%BA%BC%E6%98%AFtwo-stage-%E7%89%A9%E4%BB%B6%E5%81%B5%E6%B8%AC-fc3ce505390f">深度學習-什麼是one stage，什麼是two stage 物件偵測</a><br><a href="https://arxiv.org/pdf/2004.10934.pdf">YOLOv4論文</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDIyMjM1NA==&mid=2649029645&idx=1&sn=75b494ec181fee3e8756bb0fa119e7ce&chksm=87134270b064cb66aea66e73b4a6dc283d5750cfa9d331015424f075ba117e38f857d2f25d07&token=1097604967&lang=zh_CN#rd">Skip-Connect</a><br><a href="https://laplacetw.github.io/data-sci-yolo-accuracy/">AP指標</a><br><a href="https://zhuanlan.zhihu.com/p/147728810">YOLOv4論文筆記</a><br><a href="https://twgreatdaily.com/F5T1s3EBfGB4SiUwc5ty.html">Bag-of-Freebies</a></p></div>]]></content>
      
      
      <categories>
          
          <category> object detection </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda-Python懶人包</title>
      <link href="/larry891001/2021/08/02/Sklearn/"/>
      <url>/larry891001/2021/08/02/Sklearn/</url>
      
        <content type="html"><![CDATA[<h3 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h3><img src = "data:image/png;base64,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" style="zoom:80%"><p>這裡先介紹一個非常強大的懶人包<a href="https://www.anaconda.com/">Anaconda</a>，Anaconda可以當作是Python的懶人包，裡面包含了Python常用的資料分析、機器學習、視覺化的套件。下載完了之後會有一個Navigator，這個navigator十分方便，可以讓你快速的安裝想要的套件，而且操作簡單。<br><img src = "https://i0.wp.com/weikaiwei.com/wp-content/uploads/2019/08/image-2.png"><br>這裡介紹幾個比較常用的套件</p><div class="note simple"><p>Numpy: Python做多維陣列（矩陣）運算時的必備套件，比起Python內建的list，Numpy的array有極快的運算速度優勢，在做machine learning資料處理的時候，時常會用到這個套件。</p></div><div class="note simple"><p>Pandas： pandas 是 Python 的一個資料分析函式庫，提供如 DataFrame 等十分容易操作的資料結構，是近年做數據分析時不可或需的工具之一</p></div><div class="note simple"><p>Matplotlib： 基本的視覺化工具，可以畫長條圖、折線圖等等…，指令十分簡單</p></div><div class="note simple"><p>Notebook(Jupyter notebook): 一個輕量級web-base 寫Python的工具，在資料分析這個領域很熱門，雖然功能沒有比Pycharm, Spyder這些專業的IDE強大，但只要code小於500行我覺得用Jupyter寫非常方便，Jupyter也開始慢慢支援一些Multi cursor的功能了，可以讓你一次改許多的變數名稱。</p></div><p>另外，安裝完Anaconda之後會獲得一個叫Conda的指令可以用，可以讓你用conda管理不同Python的版本以及套件，詳情可參考：<a href="http://www.jianshu.com/p/2f3be7781451">http://www.jianshu.com/p/2f3be7781451</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>86-不存在的戰區</title>
      <link href="/larry891001/2021/07/11/%E5%8B%95%E6%BC%AB/86%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%88%B0%E5%8D%80/"/>
      <url>/larry891001/2021/07/11/%E5%8B%95%E6%BC%AB/86%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%88%B0%E5%8D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="劇情介紹"><a href="#劇情介紹" class="headerlink" title="劇情介紹"></a>劇情介紹</h3><p><font color=#FF0000>引用維基百科</font><br>聖瑪格諾利亞共和國每天都遭受著鄰國「帝國」的無人兵器「軍團Legion」的侵略。萬幸的是，共和國也成功研發出同型兵器「破壞神」以應對其攻勢，並勉強在沒有人員傷亡的情況下，化解了來自鄰國的威脅。</p><p>書面上確實沒有人員傷亡，可是，實際上傷亡者並非為零。因為在共和國85區之外，依賴不存在的軍團「86」，而被烙上「86」印記的少年少女們會駕駛著「有人駕駛的無人機Regios」，並日以繼夜地戰鬥著。</p><p>率領著年輕士兵昂首邁向戰爭與黃泉的少年辛，與指揮官通過通信同步指揮著他們作戰、名為蕾娜的少女指揮管制官（Handler），發生在他們兩人之間激烈又悲慘的戰鬥以及離別的故事，在此拉開帷幕<br><img src="https://p2.bahamut.com.tw/B/2KU/98/a78c19efb5369b39902789e0ae1c7hq5.JPG?v=1619412637909" style="zoom:80%"></p><h3 id="心得感想"><a href="#心得感想" class="headerlink" title="心得感想"></a>心得感想</h3><p><font color=#FF0000>心得可能涉及據透</font><br>————————————————————-防雷線——————————————————————–<br>這部可以說是把人性的險惡刻劃的非常深刻。每天的新聞報導上共和國聲稱自己製造出能與帝國「無人機」軍團互相抗衡的無人機，每天的死亡人數都顯示為”0”人。但實際上這個「無人機」，卻是有人駕駛的。</p><p>在這個國家中有分為兩種人一種是較為高貴的「白銀種」，另一種稱為「有色種」。而這些「無人機」就是由這些「有色種」所駕駛的，由於他們並沒有被當成人來看待，甚至把他們稱為「豬」，就算他們死亡，自然不代表人死亡，所以每天的死亡人數都是”0”人。共和國象徵自由、和平、博愛的五色旗真的是非常諷刺。</p><p>這部可以說是本季的黑馬之一，一開始的畫面讓我有一種這部是類似鋼彈的感覺。我個人並不是很喜歡這種類型的作品，但這部的故事內容、節奏以及運鏡方式實實震撼了我，對每一個角色的刻畫也都是毫不馬虎，每一個隊員都有自己的故事其駕駛的無人機上面也都有屬於自己的標誌。</p><p>原本有20人左右的小隊，隨著戰爭一個一個慢慢的消失。看到中間其實會有蠻多疑惑的，像是為什麼他們不反抗，為什麼明明會死卻還是選擇戰鬥，後面的集數都會解這些問題。總之，看這部前胃藥先準備好。</p><h3 id="推薦指數"><a href="#推薦指數" class="headerlink" title="推薦指數"></a>推薦指數</h3><p>&#x1F44D;&#x1F44D;&#x1F44D;&#x1F44D;&#x1F44D;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 動漫 </tag>
            
            <tag> 胃痛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文豪野犬</title>
      <link href="/larry891001/2021/05/12/%E5%8B%95%E6%BC%AB/%E6%96%87%E8%B1%AA%E9%87%8E%E7%8A%AC/"/>
      <url>/larry891001/2021/05/12/%E5%8B%95%E6%BC%AB/%E6%96%87%E8%B1%AA%E9%87%8E%E7%8A%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="劇情介紹"><a href="#劇情介紹" class="headerlink" title="劇情介紹"></a>劇情介紹</h3><p>被孤兒院趕出來的少年中島敦在瀕臨餓死之際，救了正在有”自殺”嗜好的太宰治，兩人一起解決了”吃人虎”事件，並被推薦進<br>「武裝偵探社」。主要故事發生在進入偵探社之後，偵探社發生的各種事件，以及他們如何突破各種困難以及考驗。</p><h3 id="主要人物簡介"><a href="#主要人物簡介" class="headerlink" title="主要人物簡介"></a>主要人物簡介</h3><p><code>中島敦</code><br><code>能力名:「月下獸」</code><br><img src="data:image/jpeg;base64,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" style="zoom:80%"/></p><p><code>太宰治</code><br><code>能力名:「人間失格」</code><br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQmJum7Xv9VYZhczDzeUkSeVCU8f-WeGRu9Dw&usqp=CAU" style="zoom:80%"></p><p><code>宮澤賢治</code><br><code>能力名:「風雨無懼」</code><br><img src="data:image/jpeg;base64,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" style="zoom:80%"></p><p><code>與謝野晶子</code><br><code>能力名:「君死給勿」</code><br><img src="data:image/jpeg;base64,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" styel="zoom:80%"></p><p><code>國木田獨步</code><br><code>能力名:「獨步吟客」</code><br><img src="data:image/jpeg;base64,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" styel="zoom:80%"></p><p><code>谷崎潤一郎</code><br><code>能力名:「細雪」</code><br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTYh72xqDWCoBkGGxsjwF1JGrIF2V7CJge3oQ&usqp=CAU" styel="zoom:80%"></p><p><code>江戶川亂步</code><br><code>能力名:「超推理」</code><br><img src="data:image/jpeg;base64,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" styel="zoom:80%"></p><p>More info: <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E8%B1%AAStray_Dogs">文豪Stray Dogs</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
